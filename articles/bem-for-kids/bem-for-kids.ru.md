# БЭМ для начинающих и не только

Эта статья написана по мотивам БЭМапа с одноименным названием [БЭМ для начинающих](https://www.youtube.com/watch?v=Ai-yt0b8iKE&t). 

Нас часто спрашивают о вёрстке по БЭМ и про технологии, которые мы используем: почему нужно делать так, а не иначе? Зачем мы создали целый стек новых технологий, когда можно пользоваться готовыми? Зачем придумали длинные и некрасивые имена в классах? 

На БЭМапе Владимир Гриненко дал ответы на большинство ваших вопросов. Мы решили их увековечить в статье.

**Основные почему:**
* Почему не используем ID?
* Почему не используем селекторы тега?
* Почему не используем селеторы атрибутов?
* Почему не используем универальный селектор?
* Почему не используем общий сброс стилей?
* Почему не используем вложенные селекторы?
* Почему не совмещаем тег и класс в селеткоре?
* Почему не используем комбинированные селеторы?

**Немного теории и практики:**
* Основы БЭМ
* Микс блоков и элементов
* Удобство параллельной разработки и верстка блоками
* БЭМ для JavaScript
* Шаблоны в БЭМ
* Тестирование верстки

## Зачем вам БЭМ

БЭМ предоставляет единые правила написания и хранения кода, которые помогают масштабировать и повторно использовать код, увеличить производительность и упростить командную работу. Даже если вся ваша команда — это вы сами, БЭМ может быть вам полезен. 

Чтобы понять, как «работает» БЭМ, мы рассмотрим простой пример web-страницы:

* [HTML-разметка](https://gist.github.com/innabelaya/be3ac2f2bc9b3466afba12bfb6dd1d8c)
* [CSS](https://gist.github.com/innabelaya/895cb5bd6efe4768588a9895f80bbc07)
* [Сохраненный проект в JSFiddle]()


TODO: дополнить, когда допишу статью
БЭМ помогает решить следующие задачи:
* повторно использовать верстку
* безболезненно менять куски верстки местами в одном проекте
* переносить готовую верстку из проекта в проект 
* создавать стабильный и предсказуемый код.
* писать понятный код. 

## Основные Почему?

### Не используем идентификаторы (ID селекторы)

Весь смысл ID в том, что он определяет уникальное имя элемента. Если имя уникально, то второй раз в интерфейсе его использовать не получится. Это мешает реализовать принципы БЭМ о повторном использовании кода.

#### Возможные исключения

Первое распространенное мнение и заблуждение, что ID обязательно нужен для работы с JavaScript. Однако современным браузерам не важно, с какими данными работать: с ID или классами. Браузер одинаково быстро обработает любой селектор.

Второй распространенный случай применения ID — это тег `<label>`. Но, если завернуть `<label>` в контрол, ID становится не нужен. Конечно, если сделать это не получается, тогда ID придется оставить.

```html
<input id="идентификатор"><label for="идентификатор">Текст</label>
<label><input type="..."> Текст</label>
```

Третий допустимый случай применения ID — установка якоря на странице. 

### Не используем селекторы тега

Селекторы тега нестабильны и изменчивы, потому что HTML-разметка страниц часто меняется. Новый дизайн сайта может поменять вложенность разделов и изменить уровень заголовоков с `<h1>` на `<h3>`, или превратить абзац `<p>` в тег `<div>`. 

Любые перечисленные действия с тегами могут сломать существующую разметку и стили. 

Если стили проекта написаны на селекторы тега, то перенос верстки в другой проект становится сложной задачей. Набор тегов ограничен, поэтому при использовании верстки из одного проекта в другом вероятность столкнуться с конфликтами стилей, написанных на одни и те же теги, возрастает в разы. Стили будут перекрываться, накладываться и ломаться.

Даже расширенный набор семантических тегов не может выразить все потребности верстки. Рассмотрим распространенный пример макета: на странице расположена шапка с логотипом, по клику на который открывается главная страница сайта. 

Попробуем написать разметку с помощью тегов. Для вставки каринки существует тег `<img>`. Но он не может показать, что картинка — это логотип. Для перехода на главную страницу воспользуемся тегом `<a>`. Но в проекте все ссылки будут выражены тегом `<a>`, и нам нужно уметь отличать ссылку слоготипа от ссылки в навигационном меню и от обычной ссылки в контенте страницы. Все эти ссылки будут выражены тегом `<a>`, но все они будут иметь совершенно разную семантику. 

```html
<header>
	<a href="/">
		<img src="img.logo.png" alt="Лого">
	</a>
</header>
```

Чтобы создать разметку, не получится полностью полагаться на назания компонентов, из которых строится интерфейс. Ссылка логотипа со всех страниц ведет на главную страницу сайта, а на самОй главной странице уже нет необходимости размещать такую ссылку. Поэтому на главной странице тег `<a>` будет заменен на `<span>` или `<div>`. 

```html
// Код для index страницы
<header>
	<span>
		<img src="img.logo.png" alt="Лого">
	</span>
</header>
```

Продолжим разбирать пример со ссылками: в шапке ссылки должны выглядеть иначе, чем в тексте. Для них понадобятся отдельные стили, которые отменят подчеркивание и синий цвет:

```css
header a {
	...
}
```

Но на главной странице ссылка в логотипе выражена тегом `<span>`, а для тега `<span>` отменять подчеркивание и синий цвет не нудно. Поэтому часть правил придется записать так:

```css
header a,
header span,
{
    ...
}
```

Увидев такой код, разработчику будет сложно понять, почему ссылке заданы те же стили, что и тегу `<span>`. Что имел в виду автор, и можно ли теперь что-то менять, когда дизайнер вообще убрал логотип со страницы. Можно ли удалить эти стили или пусть остануться на всякий случай, чтобы ничего не поломалось, мало ли что за `<span>` может быть в шапке на какой-нибудь странице проекта.

Если записать стили для логотипа с помощью селектора класса с именем `logo`, станет однозначнее, к какому компоненту интерфейса эти стили относятся: 

```
.logo {
	
}
```

Теперь,  если дизайнер решит убрать логотип, то стили для логотипа можно удалять без проблем. 

Селектор `header a` также не информативен: он может содержать CSS-правила для ссылки в меню шапки, ссылки с логотипа или, например, ссылки на профиль автора. Селектор класса `.logo`, напротив, сразу ограничивает круг ответственности. Даже если дизайнер решит перенести логотип из шапки в подвал, стили не сломаются.

#### Возможные исключения

Допускается объединять селекторы тега и класса для изменения блока контекстом. Один блок размещается в составе другого, чтобы правила родительского блока применились каскадом к вложенным блокам.

Самый распространенный случай использования контекста для стилизации блока — реализация блоков с комментариями в блогах или форумах любой CMS-системы.

Например, можно заранее определить правила для основных тегов, которые может применить пользователь:

```html
<div class="content">
	...
</div>
```

Внутри пользователь может написать любой текст, вставить картинки, добавить любую разметку. Но чтобы оставаться в рамках дизайна сайта и ограничить фантазию пользователя, нужно заранее определить стили всех возможных элементов. Можно даже использовтаь `!important`, чтобы наверняка гарантировать приоритет стилей. 

```css
.content a {
	
}

.content p {
    font-family: Arial, sans-serif;
    text-align: center; 
}
```

### Не пользуем общий сброс стилей (reset)?

Общий сброс стилей это по сути те же глобальные CSS-правила, созданные для всей страницы. Всё глобальное, оказывающее влияние на все узлы верстки, нарушает независимость компонентов и затрудняет их повторное использование.

В БЭМ мы не используем reset и normalize даже для отдельно вязтого компонента. 
Что происходит во время ресета или нормалайза — вы отменяете существующие стили и автоматически подменяете их другими стилями, которые потом в процессе работы приходится всё равно изменять и дорабатывать. В итоге разработчик вынужден писать стили, кторые перекрывают то, что только что сбросили с помощью reset. Очень похоже на тот самый monkey business, который так не любят все разработчики.

### Не пользуем универсальный селектор (*)?

Универсальный селектор сообщает о том, что какой-то стиль повлиял на все узлы в верстке. Если разработчик захочет перенести часть верстки в другой проект, у него несколько решеинй, чтобы стили не сломались: 
* переносить в проект и стили под «звездочкой». Но тогда универсальный селектор может неожиданно повлиять на существующие стили в новом проекте.
* менять все стили в переносимой верстке, добавляя всё, что давала «звездочка».

Универсальный селектор не только затрудняет повторное использование верстки в разных проетках, но и может сделать ваш код непредсказуемым. Например, если вы захотите использовать компонент из библиотеки, универсальный селектор может повлиять на стили этого компонента. 

Общие стили не выигрывают время. Рассмотрим на примере: дизайнер приносит вам макет, в котором у заголовков скорее всего заданы отступы (`margin: 12px; padding: 30px;`). Вы сначала сбрасываете все стили `* { margin: 0; padding: 0; }`, а потом снова выставляете отступы, как в макете. То есть делаете бессмысленную работу. 

### Не используем вложенные селекторы

Вложенные селекторы увеличивают связность кода и делают его повторное использование невозможным.
Методология БЭМ допускает использование вложенных селекторов, но рекомендует свести их к минимуму. 

Вложенность уместна, если нужно изменить стили элементов в зависимости от состояния блока или заданной темы:

```css
.button_hovered .button__text
{
    text-decoration: underline;
}

.button_theme_islands .button__text
{
    line-height: 1.5;
}
```

### Не используем комбинированные селекторы

Комбинированные селекторы (например, `.button.button_theme_islands`) имеют более высокую специфичность, чем одиночные селекторы, что усложняет задачу их переопределения.

```html
<button class="button button_theme_islands">...</button>
```

CSS-правила заданы в селекторе `.button.button_theme_islands`.

Допустим, блоку добавили модификатор active с значением true:

```html
<button class="button button_theme_islands button_active">...</button>
```

Селектор `.button_active` не переопределит свойства блока, записанные как `.button.button_theme_islands`, так как специфичность `.button.button_theme_islands` выше, чем у `.button_active`. Для успешного переопределения селектор модификатора блока также должен быть скомбинирован с селектором `.button` и объявлен ниже `.button.button_theme_islands`, так как специфичность обоих селекторов одинакова:

```css
.button.button_theme_islands {}
.button.button_active {}
```

Если использовать простые селекторы классов, переопределение стилей не вызовет проблем:

```css
.button_active {}
.button {}
```

### Не совмещаем тег и класс в селекторе

Объединение тега и класса (например, `button.button`) повышает специфичность CSS-правил, что усложняет задачу их переопределения. Это приводит к войнам значимости, при которых таблицы стилей загружаются излишне сложными селекторами.

```html
<button class="button">...</button>
```

CSS-правила заданы в селекторе `button.button`.

Допустим, блоку добавили модификатор `active` с значением `true`:

```html
<button class="button button_active">...</button>
```

Селектор `.button_active` не переопределит свойства блока, записанные как `button.button`, так как специфичность `button.button` выше чем у `.button_active`. Для успешного переопределения селектор модификатора блока также должен быть скомбинирован с тегом `button.button_active`.

В результате развития проекта могут, например, появиться блоки с селекторами `input.button`, `span.button` и `a.button`. В таком случае все модификаторы блока `button` и вложенные в него элементы потребуют четыре разные декларации для каждого случая.

### Не используем селекторы атрибутов

Селекторы атрибутов по информативности уступают селекторам классов. Чтобы доказать это, рассмотрим пример с формой поиска в шапке: 

```html
<header>
	<form action="/">
		<input name="s">
		<input type="submit">
	</form>
</header>
```

Воспользуемся селекторами атрибутов, чтобы записать стили для формы:

```css
header input[type=submit],
header input[type=checkbox] {
	width: auto;
	margin-right: 20px;
}

header input[type=checkbox] {
	margin: 0;
}
```

В таком примере невозможно однозначно определить по именам селекторов, что стили относятся к форме поиска. Нагляднее записать классами. В классах нет ограничений, чтобы писать понятно.

Можно записать, например, так:

```css
.form .search {
	...
} 
```

Код стал более однозначным: теперь понятно, что стили относятся к форме, которая отвечает за поиск. 

Но вложенность селекторов по-прежнему повышает специфичность CSS-правил и мешает безболезненно переносить верстку из проекта в проект. Попрбуем от нее избавиться. Для этого нам понадобится БЭМ. 

> **Короткие выводы**
>
> * Классы — единственный селектор, который позволяет организовать стили проекта и не ограничивать при этом повторное использование верстки.
> * Вложенные селекторы, общий сброс стилей и универсальный селектор делают повторное использование кода невозможным. 
> * Вложенность повышает вес селектора и затрудняет переопределение стилей.






**Немного теории и практики:**
* Основы БЭМ
* Микс блоков и элементов
* Удобство параллельной разработки и верстка блоками
* БЭМ для JavaScript
* Шаблоны в БЭМ
* Тестирование верстки






## БЭМ. От теории до практики

БЭМ — методология, которая использует классы, чтобы повторно использовать верстку и понимать, какие компоненты инрефейса зависят друг от друга. Чтобы при переносе не терять составные части любого компонента. 

### Основы БЭМ

В БЭМ любой интерфейс делится на [блоки](), которые могут включать в себя [элементы](). Элементы не существуют вне блока. Именно блокам и элементам посвящены первые две буквы в аббревиатуре БЭМ.

Рассмотрим тот же пример с формой. В БЭМ-проекте форма будет выражена блоком `form`. В HTML имя блока всегда записывается в атрибуте `class`: 

```html
<form class="form" action="/">
```

Все части формы (блок `form`), которые не имеют смысла в отрыве от нее, считаются элементами блока `form`. Таким образом поле ввода (`search`) и кнопка (`submit`) — это элементы блока `form`. Принадлежность элемента к блоку также выражается в имени через классы: 

 ```html
<form class="" action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

Суть [именования]() компонентов в БЭМ в том, что в имени можно явно указать связь блока и его элементов.

Обратите внимание, что имя блока отделяется от имени элемента специальным разделителем. В классической схеме именования в БЭМ для разделителя используются два подчеркивания. Разделители могут быть любыми. Существуют альтиернативные схемы, и каждый разработчик выбирает наиболее удобную для себя. Важно, чтобы разделители давали возможность на программном уровне отличать блоки от элементов и модификаторов. 

Имя блока задает пространство имен его элементов и явно показывает связь между компонентами интерфейса. 

Вернемся к примеру. Из имен селекторов очевидно, что для переноса формы в другой проект, необходимо скопировать все ее составляющие: 

```css
.form__search {
	
}

.form__submit {
	
}
```
 
Запись имен в классах с помощью блоков и элементов решает еще одну важную проблему: избавляет от вложенности селекторов. У всех селекторов в БЭМ-проекте одинаковый вес. То есть переопределять стили теперь гораздо удобнее. 

Теперь, когда вам понадобится такая же форма на странице или в другом проекте, достаточно будет просто скопировать ее разметку и стили. 
 
### Третья буква в аббревиатуре БЭМ

Официально буква «М» означает «модификатор», но негласно под нее попадает еще одно очень важное понятие в БЭМ – «микс». И модификаторы и миксы измененяют блок и его элементы. Давайте рассмотрим подробнее.

#### Модификаторы

Предположим, в проекте нужна такая же форма поиска, которую мы рассмотрели выше. Она будет выполнять те же функции, но должна выглядеть по-другому (напрмер, разный вид у форм поиска в шапке и в подвале страницы). Первое, что может прийти в голову — это написать форме дополнительные стили: 

```css
header .form {
	
}

footer .form {
	
}
```

Так можно решить эту задачу: вес селектора `header .form` выше, чем у `form`, значит правила будут перекрываться. Но мы уже [обсудили](), что вложенность селекторов связывает код и мешает его переиспользовать. Значит такое решение не подходит. В БЭМ можно добавить блоку новые стили с помощью модификатора: 

```html
<form class="form form_type_original" action="/">   // Добавили модификатор form_type_original
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

Запись `<form class="form form_type_original"></form>` говорит о том, что блоку `form` присвоен модификатор `type` со значением `original`. Имя модификатора отделяется от имени блока или элемента одним подчеркиванием.

Наличие модификаторов опционально. Модификаторы позволяют комбинировать разные свойства блока, так как можно использовать неограниченное количество модификаторов. Но блоку или элементу нельзя одновременно присвоить разные значения одного и того же модификатора.
 
Форма может быть уникальна по разным показателям - цвету, размеру, типу, теме оформления. Так одна и та же форма может выглядеть по-разному и при этом быть одного размера:

```
<form class="form form_type_original form_size_m form_theme_forest"></form>
<form class="form form_type_original form_size_m form_theme_sun"></form>
```

Селекторы для каждого модификатора всё равно будут иметь один вес: 

```css
.form_type_original {
	
}

.form_size_m {
	
}

.form_theme_forest {
	
}
```

Модификатор содержит только дополнительные стили, которые как-то изменяют исходную реализацию блока. Это позволяет один раз написать, как должна выглядеть универсальный блок и добавить в стили модификатора только те свойства, которые отличают блок от его исходного вида. 

```css
.form {
	
} 

. form_type_original {
	
}
```

Поэтому модификатор всегда должен находиться на одном DOM-узле с блоком или элементом, к которому он относится.

```
<form class="form form_type_original"></form>
```

Неверная форма записи:

```
<form class="form_type_original"></form>   // Удалили имя блока из класса 
```

Модификатор позволяет получать очень частные случаи использования общих компонентов. При этом код блока или элемента не меняется, на DOM-узле просто создается нужная комбинация из модификтаоров.

#### Миксы

Миксом называется одновременное размещение нескольких БЭМ-сущностей (блоков, элементов, модификаторов) на одном DOM-узле. 

Миксы позволяют:

* создавать семантически новые компоненты интерфейса на основе существующих;
* совмещать поведение и стили нескольких сущностей без дублирования кода;
* одинаково форматировать разные HTML-элементы.

Различия блоков могут быть не только визуальными, блоки могут быть семантически разными. Например, форма поиска, форма регистрации и форма заказа товаров — это всё формы, и в верстке они будут выражены блоком `form`, хотя общих стилей у них практически не нет. Отобразить такие отличия с помощью модификаторов невозможно. 

Можно попробовать вынести общие стили для таких блоков, но повторно использовать такой код не получится: 

```css 
.form,
.search,
.register {
	
}
```

Рассмотрим, как можно создать семантически разные блоки с помощью микса на примере той же формы: 

```html
<form class="form " action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

В селекторе класса `.form` описаны все стили, которые есть у любой формы (заказов, поиска или регистрации):

```css
.form {
	
}
```

Теперь нужно сделать из универсальной формы форму поиска. Для этого в проекте необходимо создать дополнительный класс `search`, который отвечает только за поиск. Чтобы объединить стили класса `.form` и `.search`, нужно просто разместить эти классы на одном DOM-узле:

```html
<form class="form search" action="/">          // Микс блоков form и search
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

В данном случае класс `.search` — это отдельный блок, который определяет поведение формы и отвечает за поиск. У этого блока не может быть модификаторов, отвечающих за форму, темы, размеры. Такие модификаторы уже есть у универсальной формы.

Рассмотрим еще один пример, когда меняется семантика компонента. Для примера возьмем навигационное меню в шапке страницы, в котором все пункты меню должны стать ссылками:

```
<nav class="menu">
	<a class="link" href=""></a>
	<a class="link" href=""></a>
	<a class="link" href=""></a>
</nav>
```

Нужная функциональность для ссылок уже реализована в проекте в блоке `link`. Но ссылки в меню должны выглядеть не так, как сслыки в тексте. Существует несколько способов:

Первое, что может прийти в голову — это создать модификатор для пункта меню, который превратит пункт в ссылку: 

```
<nav class="menu">
	<a class="menu__item menu__item_link" href=""></a>
	<a class="menu__item menu__item_link" href=""></a>
	<a class="menu__item menu__item_link" href=""></a>
</nav>
```

Но в таком случае для реализации модификатора придется скопировать поведение и стили блока `link`. Это приведет к дублированию кода.

Правильнее воспользоваться миксом универсального блока `link` и элемента `item` блока `menu`:

```
<nav class="menu">
	<a class="link menu__item" href=""></a>
	<a class="link menu__item" href=""></a>
	<a class="link menu__item" href=""></a>
</nav>
```

Микс двух БЭМ-сущностей позволит применить базовую функциональность ссылок из блока `link` и дополнительные CSS-правила из блока `menu`, и не копировать код.


##### Врапперы не нужны!?

В БЭМ стили, отвечающие за внешнюю геометрию и позиционирование, задаются через родительский блок.

Рассмотрим на примере универсального блока меню, который нужно разместить в шапке. В верстке блок меню должен отступать от родителького блока на 20px. Превое, что хочется сделать — написать стили с отступами самому блоку мнею:

```css
.menu {
	margin-left% 20px;
}
```

Как только вы это сделаете, ваш блок меню перестанет быть универсальным. Если понадобится разместить такой же блок меню в подвале но с другими отступами, вам придется править стили. 

Второе, что можно сделать — создать модификатор для блока меню и написать так: 

```
<div>
	<ul class="menu menu_type_header">
		<li class="menu__item"><a href=""></a></li>
		<li class="menu__item"><a href=""></a></li>
		<li class="menu__item"><a href=""></a></li>
	</ul>
</div>
```

```css
.menu_type_header {
	margin-left% 20px;	
}

.menu_type_footer {
	margin-left% 30px;	
}
```

Но в таком случае у нас появляется два типа меню, а это не так. Меню остается одно и то же.\

Третий вариант определить внешнее позиционирование блока — вложить блок `menu` в абстрактную обертку (например, блок `wrapp`), где определить все отступы:

```
<div class="wrap">
	<ul class="menu">
		<li class="menu__item"><a href=""></a></li>
		<li class="menu__item"><a href=""></a></li>
		<li class="menu__item"><a href=""></a></li>
	</ul>
</div>
```

Чтобы окончательно отказаться от соблазна создавать модификаторы и менять стили самого блока для позиционирования его на странице, нужно осознать, что отступ от родительского блока — это не свойство вложенного блока быть с таким отступом. Это свойство родительского блока - знать, что вложенный в него блок должен отступать от границы на определенное количество пикселей. 

Знания про позиционирование вложенных блоков описываются в элементах родительского блока. Затем элемент родительского блока миксуется к вложенному блоку. В таком случае вложенный блок не специфицирует никакие отступы и может быть легко переиспользован в любом месте.

Продолжим рассматривать наш пример:

```
<div>
	<ul class="menu header__menu">
		<li class="menu__item"><a href=""></a></li>
		<li class="menu__item"><a href=""></a></li>
		<li class="menu__item"><a href=""></a></li>
	</ul>
</div>
```

Здесь внешняя геометрия и позиционирование блока `menu` задана через элемент `header__menu`. Блок `menu` не специфицирует никакие отступы и может быть легко переиспользован в любом месте.

Элемент родительского блока (в нашем случае это `header__menu`) полностью решает задачу абстрактных блоков-оберток, отвечающих за внешнее позиционировнаие блока. А имя элемента 1




если внутренни враппер может переезжать с проекта на проект вместе с блоком. 


5. Модификаторы нужны для модификации блоков или элементов

6. Элементы - Это части блоков, которые не имеют смысла вне своего родителя. Позволяют экономить на пересечении имен классов, легче читать селекторы и гарантируют непересекаемость стилей (вес селектора сохраняется).

7. 


Удобство параллельной разработки. 

В макете любого сайта много повторяющихся деталей. Шапка и подвал понятно, но помимо этого все ссылки выглядят одинаково, все кнопки одинаковые, панель навигации, есть стоит кирпичи например привюшка чего-то 










пока никуда не попало: 


3. 
// Изменение блока контекстом - для этого допускается объединять селекторы тега и класса
Изменение блока производится при помощи размещения одного блока в составе другого. Правила родительского блока применяются каскадом к вложенным блокам.

Важно Изменять внешний вид и поведение блока контекстом следует только в том случае, если невозможно использовать микс. Изменения с помощью контекста ограничивают независимость блоков.

Самый распространенный случай использования контекста для стилизации блока — реализация блоков для комментариев в блогах или форумах любой CMS-системы.

Например, можно заранее определить правила для основных тегов, которые может применить пользователь:

<div class="content">
	...
</div>

И тут внутри может происходить любой текст, картинки, разметка, которую захочет пользователь. Но У нас же есть дизайн сайта и мы не хотим получить жирные курсиыные подчеркнутые заголовки комментариев. Для этого нам необходимо заранее определить стили всех возможных элементов. Возможно даже расставить им important!, чтоб эти стили никто не мог перекрыть. 

```css
.content a {
	
}

.content p {
    font-family: Arial, sans-serif;
    text-align: center; 
}
```
///
















В конце в выводах: 

если знать, как выглядит хорошее, плохого не захочется. 