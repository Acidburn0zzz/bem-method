# Руководство для начинающих

1.  ID плохо использовтаь так как не получится повторно использовать верстку

2. Вложенность мешает, если нужно повторно использовтаь верстку ил иперенести часть интерфейса на новое место.


Через какое-то время вы обнаружите, что так или иначе какие-то части удобно использовать не только в текущем проекте, но и скопировать их на соседний проект. Это копирование усложняется, если использовтаь вложенные селекторы


Существует мнение, что ID можно использовать для JavaScript и не нужно использовать для верстки. Сейчас попробуем развенчать и этот миф: для JS вам не нужно использовтаь ID. Современным браузерам совершенно не важно, будет ли это селектор по ID или по классу. Браузер одинаково быстро обработает и тот и тот селектор. 

Для лейбла: В ситуации когда вы можете завернуть ваш лейбл в контрол, Id тоже становится не нужен. Если завернуть в контрол нельзя, тогда нужен ID.

Еще один валидный кейс использования ID - если нужно поставить якорь посреди страницы. 


----------
как в старом проекте перейти на БЭМ? 
все новые стили писать по БЭМ. Старые рефакторить по мере того, как будете с ними сталкиваться.

--------


3. Селектор на теги мешает повтороно использовтаь код, переносить его с места на место из проетка в проект, тк там может другой разраотчик на эти же теги написать свои стили. И они будут перекрываться, накладываться, ломаться.


Если тег поменялся 
Возможна такая ситуация, когда контролы, которые рисует браузер не устраивают разработчика, тогда начинем их переделывать. Но достоаточно сложно переделать нативный контрол. Сложно на одном дом-узле сделать все, что вам когда-либо может понадобиться. При этом у пользователей есть позможность влиять на отоборажение нативных контролов с помощью настроек. Поэтому это вообще неблагодарное дело - переделывать и улучшать нативные контролы. Захочется завернуть нативный контрол во что-то. 

Еще много случаев, когда например, усложнилась структура сайта и заголовок уровня h1 стал h3. И так далее. Абзац стал дивом. 
из этой ситуации становится понятно, что неудобно использовтаь селекторы на теги. 

Набор семантических тегов крайне ограничен и не выражает тех потребностей, которые у вас возникнут, если вы попытаетесь сверстать какой-то макет. Дизайнер вам нарисует интерфейс с понятными названиями. Но вам придется это как-то отразить в разметке. Что это не просто картинка, а логотип. 
А это не просто обычная ссылка, а ссылка с логотипа на главную страницу сайта, и надо ее отличать от соседней ссылки, которая в навигации и от той, что просто в контенте ведет на другую страницу. Это вообще семантически разные вещи. Нельзя завязываться на названия поностью. Сегодня это ссылка, а та же сслыка логотипа на главной странице уже никуда не ведет и скорее всего окажется не ссылкой, а спаном или дивом.  А семантически по смыслу он будет оставаться логотипом. 

ссылки в шапке перестают раюотать. Поэтому мы вынуждены написать стили для сслки в шапке. С той разницей, что для ссылки надо отменить подчеркивание и синий цвет, а для спана этого отменять не нужно. 

```css
header a,
header span,
{

}
```
из этого кода непонятно, почему и ссылке задали то же самое и спану. ЧТо имел в виду автор, и что теперь можно отрефакторить, когда по дизайну логотип вообще убрали. Можно ли убрать эти стили или пусть остануться на всякий случай, чтоб ничего не поломалось, мао ли что за спан может быть в хэдере на какой-нибудь странице7

Если бы назвали logo

```
.logo {
	
}
```
всем было бы понятно к чему относятся стили и если логотип у сайта отменен, то и стили для логотипа можно удалять без проблем. 

// Изменение блока контекстом - для этого допускается объединять селекторы тега и класса
Изменение блока производится при помощи размещения одного блока в составе другого. Правила родительского блока применяются каскадом к вложенным блокам.

Важно Изменять внешний вид и поведение блока контекстом следует только в том случае, если невозможно использовать микс. Изменения с помощью контекста ограничивают независимость блоков.

Самый распространенный случай использования контекста для стилизации блока — реализация блоков для комментариев в блогах или форумах любой CMS-системы.

Например, можно заранее определить правила для основных тегов, которые может применить пользователь:

<div class="content">
	...
</div>

И тут внутри может происходить любой текст, картинки, разметка, которую захочет пользователь. Но У нас же есть дизайн сайта и мы не хотим получить жирные курсиыные подчеркнутые заголовки комментариев. Для этого нам необходимо заранее определить стили всех возможных элементов. Возможно даже расставить им important!, чтоб эти стили никто не мог перекрыть. 

```css
.content a {
	
}

.content p {
    font-family: Arial, sans-serif;
    text-align: center; 
}
```
///


Про reset  - нет никакой причины сбрасыват стили. И даже использовать normalize. 

Во время ресета или нормалайза приезжает куча стилей, которые потом в процессе работы приходится изменять и дорабатывать. Напрмер пишете стили, кторые тупо перекрывают то, что вы только что там сресетили. 


4. Селектороы со звездочкой не нужны

Про универсальный селектор: 

```css
* {
	margin: 0;
	padding: 0;
}
```
Универсальный селектор тоже не нужен. 
говорит о том, что какой-то стиль повлиял на все ваши узлы и вы потом хотите какой-то кусочек взять и повторно использовать в др проекте и оказывается6 что там этой звездочки нет и правил на нее соответственно тоже. 

Или если вы взяли какой-то компонент из библиотеки компонентов и хотите использовать его в том же виде в проекте, но оказывается, что у вас где-то написан универсальный селектор, который каким-то образом влияет на этот компонент. И все сломалось. 

Оно того не стоит. Общие стили не выигрывают время. Тк у большинства браузерных компонентов уже все стоит в ноль и сбрасывать марджины и паддинги. Даже для заголовков. Дизайнер принесет вам макет, в котором у заголовков скорее всего будут заданы марджины и паддинги.  Ивы сначала сбросите их, а потом будете писать стили и выставлять их как в макете. Бессмысленная раюота. 


селектор `header a` непонятно, а `.logo` понтно и читабельно. (см выше) и с этим удобно жить. 

У вас в проекте вполне могут быть стили 

```css
header input[type=submit],
header input[type=checkbox] {
	width: auto;
	margin-right: 20px;
}

header input[type=checkbox] {
	margin: 0;
}
```

из этих имен селеткоров непонятно не однозначно, что это форма поиска и за что она отвечает. 

Если написать так

```css
.form .search {
	
} 
```
станет более однозначно, что стили к какой-то форме, отвечающей за поиск. Но тут снова возникает проблема вложенности селекторов. 
Хочется с ней побороться. Начнем с того, что разберем саму форму. Очевидно, что прсто инпут в отрыве от самой формы быть и использоваться не может. В проекте не может быть просто поисковое поле, которое ни к чему не привязано и ни за что не отвечает. Но вложенность все равно хочется убрать, тк сложенность повышает специфичность селекторов. И в последствии будт сложнее доопределять правила, досыпать новых стилей. 

И вот мы плавно подошли к истории про БЭМ. 
Главные мысли из предистории - проект делится на какие-то штучки6 которые непохожи между собой. Который засият друг от друга и которые могут называться одинаково, но быть совершенно семантически разными. 

Мы подошли к тому, что нам хочется уметь переиспользовтаь какие-то части и при этом видеть по именам в селекторах, какие части от каких зависят, чтоб понимать, что надо переносить в новый проект и быть уверенными, что ничего не сломалось. 

```html
<form class="" action="/">
			<input name="s">
			<input type="submit">
</form>
```

что одни штучки имеют свои составные кусочки и при переносе нужно уметь не потерять составные части любого компонента. И быть уверенным, что никто другой на новом проекте не перекроет наши стили своими. 
надо как-то явно научиться готоврить, что эти штучки связаны. 

мы пришли к тому, что надо делить все, что есть на странице на блоки и эелементы. В таком случае у нас форма будет выглядеть так: 

форма окажется блоком form. Показывать в HTML, что этот блок это форма мы будем просто выстявляя ей такой класс: 

```
<form class="form" action="/">
```

Информативно и очевидно. 
Все штуки, которые не могут существовать без этой формы, мы будем считать элементами этого блока. Чтобы выразить, что эта штучка является элементом этого блока мы будем использовтаь классы: Как мы выяснили до этого, все остальные теги неудобные для решения наших задач. 

 ```html
<form class="" action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

в классе мы указываем к какому блку относится этот элемент. Отделяем каким-то разделителем для читабельности. В нашем случае это два дефиса. 

И теперь глядя на такие селекторы  мы не ошибемся, что они связаны. Что при переносе формы нужно скопировать и иХ 

```css
.form__search {
	
}

.form__submit {
	
}
```
 
такая форма записи решает еще одну важную проблему - избавились от вложенности селекторов. У всех селекторов будет одинаковый вес. И проблемы с переопределением не должно теперь стоять так остро. 

И если посмотреть на код то мы получили дополнительный уроовень семантики, который невозможно получить из просто разметки: 

```html
<form class="" action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

Сразу видно, что это связанная штука, которая решает конкретную задачу. 
Теперь , когда вам нужна такая же форма на странице или в другом проекте, вы просто берете и используете ее. 


Если вам нужна такая же форма поиска, которая будет выполнять абсолютно те же функции, но будет выглядеть по-другому (напрмер, форма в шапке и в футере). Тогда мы начинаем использовтаь третю букву в аббревиатуре. 
Третья буква в аббревиатуре тоже не просто так. М - модификаор. 

Мы используем такую же форму. И первое, что может прийти в голову это написать к ней просто разные стили: 


```css
header .form {
	
}

footer .form {
	
}
```
и получить счастье тк селектор с большим весом и правила будут перекрываться. НО тогда сразу вылазят все те проблемы, что мы обсудили в начале статьи про вложенность. 

Связвать код мы не хотим, вложенность не дает свободы в повторном использовании. Значит надо уйти от проблемы - нужно в классе описать, что каждая из форм особенная и добавить стилей. 

```html
<form class="form form_type_original" action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```


Вот эта запись говорит о том, что это блок form, у которого есть модификатор type со значением original. 
```
<form class="form form_type_original">
```

Здесь для отделения модификатора используется одно нижнее подчеркивание. 

Форма может буть уникальна по разным показателям - цвету, размеру, типу, теме оформления. 
Модификаторов может быть разное количество: 

```
<form class="form form_type_original form_size_m form_theme_forest">
```
Модификаторы позволяют комбинировать разные свойства блока, просто добавляя новые мод и значения. Цвет и размер, тип и свойства.
И одна и та же форма может выглядеть по-разному и при этом быть одного размера.  

И селекторы по-прежнему будет одного веса: 

```css
.form_type_original {
	
}

.form_size_m {
	
}

.form_theme_forest {
	
}
```
Важный момент в HTML остается класс самой формы (блока) и добавляются классы модификаторов: 

```
<form class="form form_type_original form_size_m form_theme_forest">
```

Это позволяет один раз написать, как должна выглядеть универсальная форма 

```css
.form {
	
} 
```
и дрбавлять к ней в стили для модификатора только те свойства, которые отличают ее от базовой формы. 
Такая комбинация на одном дом-узле помогает получать нам из каких-то очень общих вещей очень частные вещи.

В таком подходе важно, чтоб основные стили были раньше чем стили модификаторов. Но в БЭМ и об этом можно не волноваться, подробнее читай в сборке и файловой структуре. 


Модификаторы могут использоваться и для элементов. 

напрмер: 

<nav class="menu">
	<a class="menu__item" href=""></a>
	<a class="menu__item menu__item_current" href=""></a>
	<a class="menu__item" href=""></a>
</nav>



Но если формы семантически разные - одна про поиск, другая про регистрацию, третья про заказ товаров интернет магазине, то выразить эти отличия модификаторами уже не получится. 
Но все эти формы остаются формами. И как быть в этом случае? Общих стилей у них практически не останется. 

В большинстве случаев можно было бы вынести общую часть таким образом: 

```css 
.form,
.search,
.register {
	
}
```
Но это приведет к сложностям в повторном использовании. 
Хочется чтобы каждый компонент на странице был все-таки независим и выражался одним селектором. Эту проблему решает еще один подход, который придуман в БЭМ, но в аббревиатуру не поместился - МИКСЫ. 
Миксы позволяют одновременно разместить несколько блоков на одном дом-узле. 

Для чего? 

Например, у нас есть какая-то форма: 

```html
<form class="form " action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```
и класс 

```css
.form {
	
}
```
будет отвечать за все то общее, что есть у любой формы, не важно форма заказов или поиска или регистрации. 
Но есть доп класс, который отвечает отдельно за форму поиска. И мы просто ставим такой класс рядом: 

```html
<form class="form search" action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

класс search это отдельный блок, который отвечает за поиск, Со своим внутренним миром, и разных типов и размеров он не может быть. к нему не относятся никакие модификаторы формы - темы, размеры. Но этот класс привносит в отображение и поведение всей формы. 


Миксы элемента

Модификаторы могут использоваться и для элементов. 

напрмер есть меню с пачкой ссылок: Все ссылки выражены блоком линк

```
<nav class="menu">
	<a class="link" href=""></a>
	<a class="link" href=""></a>
	<a class="link" href=""></a>
</nav>
```
 
Но нужно чтобы ссылка выглядела особенно только в меню. 

```
<nav class="menu">
	<a class="link" href=""></a>
	<a class="link menu__item" href=""></a>
	<a class="link" href=""></a>
</nav>
```

Миксуем с элементом


Про вложенность элементов: 

```
<div>
	<ul>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
	</ul>
</div>
```

рассказать про пересечение стилей. что решаем неймингом (52 минута)

рассказть про врапперы. что нет необходимости создавать врапперы для блоков. Это может решаться за счет элементов родительского блока. 

если внутренни враппер может переезжать с проекта на проект вместе с блоком. 





















