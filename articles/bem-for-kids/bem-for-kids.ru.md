# БЭМ для начинающих и не только

Эта статья написана по мотивам БЭМапа с одноименным названием [БЭМ для начинающих](https://www.youtube.com/watch?v=Ai-yt0b8iKE&t). 

Нас часто спрашивают о вёрстке по БЭМ и про технологии, которые мы используем: почему нужно делать так, а не иначе? Зачем мы создали целый стек новых технологий, когда можно пользоваться готовыми? Зачем эти длинные и некрасивые имена в классах? 

На БЭМапе Владимир Гриненко дал ответы на большинство ваших вопросов. Мы решили их увековечить в этой статье.

**Основные почему:**
* Почему не используем ID?
* Почему не используем селекторы тега?
* Почему не используем селеторы атрибутов?
* Почему не используем универальный селектор?
* Почему не используем общий сброс стилей?

**Немного теории и практики:**
* Основы БЭМ
* Микс блоков и элементов
* Удобство параллельной разработки и верстка блоками
* БЭМ для JavaScript
* Шаблоны в БЭМ
* Тестирование верстки

## Зачем вам БЭМ

БЭМ предоставляет единые правила написания и хранения кода, которые помогают масштабировать и повторно использовать код, увеличить производительность и упростить командную работу. Даже если вся ваша команда — это вы сами, БЭМ может быть вам полезен. 

Чтобы понять, как «работает» БЭМ, мы рассмотрим простой пример web-страницы:

* [HTML-разметка](https://gist.github.com/innabelaya/be3ac2f2bc9b3466afba12bfb6dd1d8c)
* [CSS](https://gist.github.com/innabelaya/895cb5bd6efe4768588a9895f80bbc07)
* [Сохраненный проект в JSFiddle]()

Сначала оговорим, чего мы ждем от применения БЭМ в проекте, не важно в большом или в таком, где один челоек и дизайнер, и менеджер, и программист — увеличения скорости разработки без потери качества. Для этого нужно научится: 
* повторно использовать верстку
* безболезненно менять куски верстки местами в одном проекте
* переносить готовую верстку из проекта в проект. 

А еще хочется, чтобы код был стабильным и предсказуемым, а рефакторинг не занимал много времени. Звучит как план? Тогда разберем по шагам:

Первое, с чего стоит начать это то, что в БЭМ, чтобы достичь перечисленные цели, **для декларации CSS-правил используются только классы**. К сожалению, как аксиому мы записать это не можем, поэтому докажем как теорему.







## Не используем идентификаторы (ID селекторы)

ID определяет уникальное имя элемента, то есть второй раз в интерфейсе его использовать не получится.

### Возможные исключения

Распространенное мнение, что ID используется для JavaScript? Эта информация устарела: современным браузерам не важно применяете вы ID или классы. Браузер одинаково быстро обработает любой селектор.

Часто ID используются для тега `<label>`. 

```html
<input id="идентификатор"><label for="идентификатор">Текст</label>
<label><input type="..."> Текст</label>
```

Бесспорно. Но в ситуации, когда вы можете завернуть ваш `<label>` в контрол, ID вам тоже не понадобится. Конечно, если сделать это не получается, тогда ID придется оставить.

Еще один допустимый пример применения ID — это установка якоря на странице. 

Во всех остальных случаях прмменяются селекторы класса.

## Не используем селекторы тега

Селекторы тега весьма нестабильны: их можно менять, передвигать по странице, удалять, вкладывать один в другой и не только. Любые перечисленные действия с тегами ломают существующую разметку и стили. Дизайнер может поменять вложенность разделов на сайте и изменить уровень заголовока `<h1>` на `<h3>`. Или прератить абзац `<p>` в тег `<div>`. 

Также набор тегов крайне ограничен. Если стили проекта написаны на селекторы тега, то перенести верстку в другой проект становится сложной задачей. В новом проекте могут существовать стили, написанные на эти же теги. При переносе верстки стили будут перекрываться, накладываться и ломаться.

Даже расширенный набор семантических тегов не может выразить всех потребностей верстки. Рассмотрим на прмере макета, в котором в шапке размещен логотип. По клику на логотип должна открываться главная страница сайта. Разработчику приходится все это отразить в разметке. Для вставки каринки существует тег `<img>`, но у этого тега нет озможности выразить, что картинка — это логотип. А тег `<a>` — это не просто ссылка, а ссылка с логотипа на главную страницу. И ее нужно отличать от другой ссылки, которая расположена в навигационном меню, и от той, которая встречается в контенте страницы и ведет на другой ресурс. Все эти ссылки будут выражены тегом `<a>`, но все они будут иметь совершенно разную семантику. 

```html
<header>
	<a href="/">
		<img src="img.logo.png" alt="Лого">
	</a>
</header>
```

Не получится полностью полагаться на назания компонентов, из которых строится интерфейс. Ссылка логотипа со всех страниц ведет на главную страницу сайта, а на самОй главной странице эта же ссылка уже не должна никуда не вести. Скорее всего, Разработчик сделает ее тегом `<span>` или `<div>`, а не ссылкой `<a>`. 

```html
<header>
	<span>
		<img src="img.logo.png" alt="Лого">
	</span>
</header>
```

Разберем пример со ссылками дальше. Ссылки в шапке должны выглядеть не так, как в тексте. Поэтому мы вынуждены написать отдельные стили для ссылки в шапке, где отменим подчеркивание и синий цвет. 

```css
header a {
	...
}
```

А вот для тега `<span>` этого делать не нужно. Поэтому часть правил запишем так:

```css
header a,
header span,
{
...
}
```

Увидев такой код, разработчику будет сложно понять, почему ссылке заданы те же стили, что и тегу `<span>`. Что имел в виду автор, и можно ли теперь что-то менять, когда дизайнер вообще убрал логотип со страницы. Можно ли удалить эти стили или пусть остануться на всякий случай, чтобы ничего не поломалось, мало ли что за `<span>` может быть в шапке на какой-нибудь странице проекта.

Если записать стили для логотипа с помощью селектора класса с именем `logo`, станет однозначнее, к какому компоненту интерфейса эти стили относятся: 

```
.logo {
	
}
```

Теперь,  если дизайнер решит убрать логотип, то стили для логотипа можно будет удалять без проблем. 

Селектор `header a` также не информативен: он может содержать CSS-правила для ссылки в меню шапки, ссылки с логотипа или, например, ссылки на профиль автора. Селектор класса `.logo`, напротив, сразу ограничивает круг ответственности. Даже если дизайнер решит перенести логотип из шапки в подвал, стили не сломаются.

### Возможные исключения

Допускается объединять селекторы тега и класса для изменения блока контекстом. Один блок размещается в составе другого и правила родительского блока применяются каскадом к вложенным блокам.

Самый распространенный случай использования контекста для стилизации блока — реализация блоков с комментариями в блогах или форумах любой CMS-системы.

Например, можно заранее определить правила для основных тегов, которые может применить пользователь:

```html
<div class="content">
	...
</div>
```

Внутри пользователь может написать любой текст, вставить картинки, добавить любую разметку. Но чтобы оставаться в рамках дизайна сайта и ограничить фантазию пользователя, нужно заранее определить стили всех возможных элементов. Можно даже использовтаь `!important`, чтобы наверняка гарантировать приоритет стилей. 

```css
.content a {
	
}

.content p {
    font-family: Arial, sans-serif;
    text-align: center; 
}
```

## Почему не пользуемся общим сбросом стилей (reset)?

Общий сброс стилей это по сути глобальные CSS-правила, созданные для всей страницы. Это нарушает независимость компонентов и затрудняет их повторное использование.

На самом деле нет никакой причины сбрасыват стили и даже использовать normalize даже для отдельно вязтого компонента. Во время ”ресета“ или ”нормалайза“ появляются новые стили, которые потом в процессе работы приходится изменять и дорабатывать. Часто разработчик вынужден писать стили, кторые перекрывают то, что только что сбросили с помощью reset. 

## Почему не пользуемся универсальным селектором (*)?

Универсальный селектор сообщает о том, что какой-то стиль повлиял на все узлы в верстке. Если разработчик перенесет часть верстки в другой проект, стили могут сломаться, так как в новом проекте не будет универсального селектора и CSS-правил, соответственно, тоже. 

Можно рассмотреть и противоположный случай, когда разработчик хочет использовать компонент из библиотеки в проекте. Если в проекте используется универсальный селектор, он может каким-то образом повлиять на компонент из библиотеки. 


```css
* {
	margin: 0;
	padding: 0;
}
```

Общие стили не выигрывают время. Рассмотрим на примере: дизайнер приносит вам макет, в котором у заголовков скорее всего заданы отступы (`margin: 12px; padding: 30px;`). Вы сначала сбрасываете все стили, а потом снова выставляете отступы, как в макете. ТО есть делатее бессмысленную работу. 

### Почему не используем атрибуты

Селекторы атрибутов тоже неинформативны и ограничены.

Рассмотрим пример с формой поиска в шапке. Если использовтаь атрибуты, то стили формы могут выглядеть так:

```css
header input[type=submit],
header input[type=checkbox] {
	width: auto;
	margin-right: 20px;
}

header input[type=checkbox] {
	margin: 0;
}
```

В таком примере имена селеткоров не дают однозначно определить, что стили относятся к форме поиска. Нагляднее записать классами. В классах нет ограничений, чтобы писать понятно.

Можно записать, например, так:

```css
.form .search {
	
} 
```

Код стал более однозначным: теперь понятно, что стили относятся к форме, которая отвечает за поиск. Но остается проблема вложенности селекторов: вложенность повышает специфичность селектора и мешает безболезненно переносить верстку из проекта в проект. Попрбуем от нее избавиться. Для этого нам понадобится БЭМ. 

> **Короткие выводы**
>
> * Классы — единственный селектор, который позволяет организовать стили проекта и не ограничивать при этом повторное использование верстки.
> * Вложенные селекторы, общий сброс стилей и универсальный селектор делают повторное использование кода невозможным. 
> * Вложенность повышает вес селектора и затрудняет переопределение стилей.

## БЭМ — методология, которая использует классы

Мы подошли к тому, что нужно уметь переиспользовать какие-то части верстки и при этом видеть по именам в селекторах, что от чего зависит, чтобы при переносе не потерять составные части любого компонента. При этом стили не должны ломаться.

БЭМ-методология позволяет все это провернуть.

Напомним, что в БЭМ любой интерфейс делится на блоки, которые могут включать в себя элементы. Рассмотрим все тот же пример с формой. В БЭМ-проекте форма будет выражена блоком `form` и в HTML имя блока всегда будет записано в атрибуте `class`: 

```
<form class="form" action="/">
```

Теперь нужно научиться явно говорить, что блоки и элементы связаны между собой. 

Все части формы, которые не имеют смысла в отрыве от нее, считаются элементами блока. ТО есть поле ввода (`search`) и кнопка (`submit`) — это элементы блока `form`. Принадлежность элемента к блоку также выражается в классах: 

 ```html
<form class="" action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

Обратите внимание, что имя блока отделяется от имени элемента специальным разделителем. Важно, чтобы разделители давали возможность на программном уровне отличать блоки от элементов и модификаторов. Классическая схема именования в БЭМ для разделителя использует два подчеркивания.

Имя блока задает пространство имен его элементов и явно показывают связь между компонентами интерфейса. Теперь очевидно, что при переносе формы, необходимо скопировать все ее составляющие: 

```css
.form__search {
	
}

.form__submit {
	
}
```
 
Форма записи с помощью блоков и элементов в классах решает еще одну важную проблему - избавляет от вложенности селекторов. У всех селекторов теперь всегда одинаковый вес. То есть переопределять стили теперь гораздо удобнее. 

Теперь, когда вам понадобится такая же форма на странице или в другом проекте, достаточно будет просто скопировать ее разметку и стили. 

```html
<form class="form" action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```
 
Но что, если вам нужна такая же форма поиска, которая выполняет абсолютно те же функции, но выглядеть по-другому (напрмер, разный вид у форм поиска в шапке и в подвале). Первое, что приходит в голову — это написать форме дополнительные стили: 

```css
header .form {
	
}

footer .form {
	
}
```

Действительно, так можно решить эту проблему: вес селектора `header .form` выше, чем у `form`, значит правила будут перекрываться. Но такое решение приводит к другой проблеме — вложенности селекторов. 

Связвать код мы не хотим, значит нужно избавится от вложенности. Для этого воспользуемся модификатором: добавим модификатор блоку, добавим стили. 

```html
<form class="form form_type_original" action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

Запись `<form class="form form_type_original"></form>` говорит о том, что блоку `form` присвоен модификатор `type` со значением `original`. 

Обратите внимание, чтобы отделить именя модификатора от имени блока или элемента, в БЭМ используется одно подчеркивание. 

Форма может быть уникальна по разным показателям - цвету, размеру, типу, теме оформления. Модификаторы позволяют комбинировать разные свойства блока: 

```
<form class="form form_type_original form_size_m form_theme_forest"></form>
```

Так одна и та же форма может выглядеть по-разному и при этом быть одного размера.  

Селекторы по-прежнему будут одного веса: 

```css
.form_type_original {
	
}

.form_size_m {
	
}

.form_theme_forest {
	
}
```

Важно! Модификаторы всегда размещаются на одном DOM-узле с блоком или элементом, к которому они относятся: 

```
<form class="form form_type_original form_size_m form_theme_forest"></form>
```

Это позволяет один раз написать, как должна выглядеть универсальная форма и добавить в стили модификатора только те свойства, которые отличают форму от ее базового вида:

```css
.form {
	
} 

. form_type_original {
	
}
```
 
Так ничего не меняя, а просто создавая на одном DOM-узле нужную комбинацию, можно из каких-то общих компонентов получить очень частные случаи использования.

> **Короткие выводы**
>
> * Любой интерфейс состоит из блоков.
> * Имя блока создает пространство имен для элементов и модификтаоров и решает проблему вложенности селекторов.

### Миксы

Бывает так, что различия блоков не только визуальные. Например, формы могут быть семантически разными: одна про поиск, другая про регистрацию, третья про заказ товаров интернет магазине. В таком случае выразить эти отличия модификаторами уже не получится. 
Но при этом все эти формы остаются формами, блоком `form`, хотя общих стилей у них практически не останется. 

Можно вынести общие стили для таких блоков: 

```css 
.form,
.search,
.register {
	
}
```

Но повторно использовать такой код вряд ли получится.
По-прежнему хочется, чтобы каждый компонент на странице был независим и выражался одним селектором. Для семантически разных блоков эту проблему решают миксы — подход, который придуман в БЭМ, но в аббревиатуру не поместился. С помоью миксов можно одновременно разместить несколько блоков на одном DOM-узле. 

Рассмотрим, как работают миксына примере все той же формы: 

```html
<form class="form " action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

В селекторе класса `.form` описаны все стили, которые есть у любой формы, не важно форма заказов, поиска или регистрации. 

```css
.form {
	
}
```

Но нам надо сделать из обычной формы форму поиска. Для этого в проекте создадим дополнительный класс `search`, который отвечает отдельно за поиск. Чтобы объединить стили класса `.form` и `.search`, нужно просто разместить эти классы на одном DOM-узле:

```html
<form class="form search" action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

В данном случае класс `search` — это отдельный блок, который отвечает за поиск. У этого блока не может быть никаких модификаторов, отвечающих за форму, темы, размеры. Зато этот класс определяет поведение формы. 

#### Миксы элемента

Элементы также можно миксовать к блокам, для 

Рассмотрим пример меню с пачкой ссылок: Все ссылки выражены блоком линк

```
<nav class="menu">
	<a class="link" href=""></a>
	<a class="link" href=""></a>
	<a class="link" href=""></a>
</nav>
```
 
Но нужно чтобы ссылка выглядела особенно только в меню. 

```
<nav class="menu">
	<a class="link" href=""></a>
	<a class="link menu__item" href=""></a>
	<a class="link" href=""></a>
</nav>
```

Миксуем с элементом


Про позиционирование пример 1:10

Позиционирование блока - миксы блока

Есть универсальное меню. Его нужно поставить на расстоянии 20пк от его родителей. Отступить вправо, чтоб он не прижимался к родительскому блоку. 
Очень распротр ситуация. Превое, что хочется сделать - написать эти стили блоку мнею

```css
.menu {
	margin-left% 20px;
}
```

а если есть менб в шапке и в подвале и отступы разные. Есть риск написать так: 

```
<div>
	<ul class="menu menu_type_header">
		<li class="menu__item"><a class="menu__link" href=""></a></li>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
	</ul>
</div>
```

```css
.menu_type_header {
	margin-left% 20px;	
}

.menu_type_footer {
	margin-left% 30px;	
}
```
как буд-то у нас ест ьдва типа меню. Но это тот же случай, что с формой про поиск и общей. Это  не какое-то свойство меню быть с отсупом в 20 пк от левого края. А это скорее свойство родительского блока (шапки) - его вложенный блок должен отступать от грацы в 20px . 

Знания про отсупы должны содержаться в блоке шапки в его эелементе. То есть у нас есть шапка и мы знаем, что внутри шапки ест ьразные неотрываемы от шапки штуки - лого, меню, форма поиска. И эти неотрываемые части должны отсупать от края 20 пк. И важно, что если меню заменить на другой блок, потому что его перенесли в сайдбар, например на форму поиска. Новый блок будет также отсупать от края 20 пк и ничего не поломается. И в то же время меню в сайдбаре не будет содержать лишнюю инфу об отсупах для шапки. у него не будет никаких стилей рпо позиуионирование. Оно будет универсальным и будет одинаково работать, независимо от того, куда бы мы его не положили. 

```
<div>
	<ul class="menu header__menu">
		<li class="menu__item"><a class="menu__link" href=""></a></li>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
	</ul>
</div>
```




Про вложенность элементов: 

```
<div>
	<ul>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
	</ul>
</div>
```

рассказать про пересечение стилей. что решаем неймингом (52 минута)

рассказть про врапперы. что нет необходимости создавать врапперы для блоков. Это может решаться за счет элементов родительского блока. 

если внутренни враппер может переезжать с проекта на проект вместе с блоком. 


5. Модификаторы нужны для модификации блоков или элементов

6. Элементы - Это части блоков, которые не имеют смысла вне своего родителя. Позволяют экономить на пересечении имен классов, легче читать селекторы и гарантируют непересекаемость стилей (вес селектора сохраняется).

7. 


Удобство параллельной разработки. 

В макете любого сайта много повторяющихся деталей. Шапка и подвал понятно, но помимо этого все ссылки выглядят одинаково, все кнопки одинаковые, панель навигации, есть стоит кирпичи например привюшка чего-то 










пока никуда не попало: 


3. 
// Изменение блока контекстом - для этого допускается объединять селекторы тега и класса
Изменение блока производится при помощи размещения одного блока в составе другого. Правила родительского блока применяются каскадом к вложенным блокам.

Важно Изменять внешний вид и поведение блока контекстом следует только в том случае, если невозможно использовать микс. Изменения с помощью контекста ограничивают независимость блоков.

Самый распространенный случай использования контекста для стилизации блока — реализация блоков для комментариев в блогах или форумах любой CMS-системы.

Например, можно заранее определить правила для основных тегов, которые может применить пользователь:

<div class="content">
	...
</div>

И тут внутри может происходить любой текст, картинки, разметка, которую захочет пользователь. Но У нас же есть дизайн сайта и мы не хотим получить жирные курсиыные подчеркнутые заголовки комментариев. Для этого нам необходимо заранее определить стили всех возможных элементов. Возможно даже расставить им important!, чтоб эти стили никто не мог перекрыть. 

```css
.content a {
	
}

.content p {
    font-family: Arial, sans-serif;
    text-align: center; 
}
```
///
















В конце в выводах: 

если знать, как выглядит хорошее, плохого не захочется. 