# БЭМ не только про CSS. Материал для начинающих и не только. 



CSS Начало пр то как пришли к классам
- не Id
- не тег
- не универсальный селектор
- не общий сброс стилей и не нормалайз

- не повышай специфичность селеткора
- не вложенные селекторы
- не совмещай тег и класс
- не комбинированные селекторы

Про БЭМ можно говорить много и рассматривать его под разными углами. В этой статье мы предлагаем посмотреть на БЭМ как на одну из стратегий ведения вашего бизнеса. Неважно, большая у вас компания или маленькая, если вы читаете эту статью, значит решили оптимизировать вашу работу, улучшить код и расти над собой и конкурентами. 

В небольших компаниях любую новую стратегию организации работы можно быстро внедрить и проверить, подходит она или нет. После нескольких итераций можно объективно оценить, приносит ли выбранная стратегия выгоду для компании. И если что-то пошло не так, можно всё быстро развернуть в другую сторону. 
С компаниями большого размера, где работают сотни людей, где вссе процессы занимают гораздо больше времени и стоят в разы дороже, такой номер не пройдет — придется идти до конца и в случае неверно выбранной стратегии терепть убытки. 

БЭМ — методология, которую используют многие курпные компании по всему миру. Что нужно сделать? изучить, понять, применить. Если сказать короче, нужно потратить на нее время. А стоит ли? Давайте разберемся. 

Сначала оговорим, чего мы ждем от применения БЭМ в своем проекте, не важно большом или в таком, где один челоек и дизайнер, и менеджер, и программист. 
К чему все стремятся? Все хотят увеличить скорость создания сайтов. Для этого нужно научится: 
* повторно использовать верстку
* безболезненно менять куски верстки местами в одном проекте
* переносить готовую верстку из проекта в проект. 

А еще хочется, чтоб код был стабильным и предсказуемым, а рефакторинг не занимал много времени. Звучит как план? Тогда разберем по шагам:

Первое, с чего стоит начать это то, что в БЭМ, чтобы достичь цели, перечисленные выше, **для декларации CSS-правил используются только классы**. К сожалению, как аксиому мы записать это не можем, поэтому докажем как теорему.

## Почему не используем идентификаторы (ID селекторы)

ID определяет уникальное имя элемента. Если имя уникально, второй раз в интерфейсе его вставить не получится. ID мешает повторно использовать верстку.

### Возможные исключения

Сейчас пытливый ум многих разработчиков может возмутиться: а как же то, что ID нужно использовать для JavaScript? Для этого ID вам тоже не нужен. Современным браузерам совершенно не важно используете вы ID или классы. Браузер одинаково быстро обработает и тот и тот селектор.

Еще один вопрос, который может возникнуть - ID нужен для тега `<label>`. 

```html
<input id="идентификатор"><label for="идентификатор">Текст</label>
<label><input type="..."> Текст</label>
```

Да, бесспорно. Но в ситуации, когда вы можете завернуть ваш `<label>` в контрол, ID тоже становится не нужен. Конечно, если завернуть в контрол не получается, тогда ID придется оставить.

Еще один годный случай, чтобы использовать ID - поставить якорь посреди страницы. 

## Почему не используем селекторы тега

Селекторы тега весьма нестабильны: им свойственно меняться, сдвигаться, удаляться и так далее, а, соответственно, и ломать существующую разметку и стили. Написав однажды CSS-правила к заголовку первого уровня `<h1>`, вы не можете быть уверены, что струтктура страницы не изменится. Вложенность разделов на сайте может усложниться: уровень заголовока `<h1>` изменится, например, на `<h3>`. Или абзац `<p>` после очередных изменений станет тегом `<div>`. 

А еще в набор тегов крайне ограничен. Если вы для стилей проекта используете селекторы тега, то возрастает вероятность, что перенести вашу верстку в другой проект не получится. В новом проекте другой разработчик может уже написать свои CSS-правила на эти же теги. При переносе верстки стили будут перекрываться, накладываться и ломаться.

Даже утвержденный не так давно набор семантических тегов не может выразить всех потребностей верстки. Рассмотрим на прмере: дизайнер рисует интерфейс: в шапке размещает логотип, по клику на который открывается главная страница сайта. А дальше вам приходится все это как-то отразить в разметке. Тег `<img>` не сможет передать, что это не просто картинка, а логотип. А тег `<a>` это не просто обычная ссылка, а ссылка с логотипа на главную страницу. Вам надо как-то отличать эту ссылку от соседней, которая расположена в навигационном меню, и от той, которая встречается в контенте страницы и ведет на другой ресурс. Это все ссылки, но у них совершенно разная семантика. 

Нельзя полностью полагаться на назания компонентов, из которых строится интерфейс. Ссылка логотипа со всех страниц будет вести на главную страницу сайта, а на самОй главной странице эта же ссылка уже не должна никуда не вести. Она, скорее всего, окажется не ссылкой `<a>`, а тегом `<span>` или `<div>`. 

Ссылки в шапке должны выглядеть не так, как ссылки в тексте. Поэтому мы вынуждены написать стили для ссылки в шапке и отменить подчеркивание и синий цвет. 

```css
header a {
	...
}
```

Для тега `<span>` этого отменять не нужно. Поэтому часть правил можно записать так:

```css
header a,
header span,
{
...
}
```

Придя на проект или заглянув в такой код через пару месяцев после его создания, будет сложно понять, почему ссылке заданы те же стили, что и тегу `<span>`. Что имел в виду автор, и можно ли теперь что-то менять, когда дизайнер вообще убрал логотип со страницы. Можно ли убрать эти стили или пусть остануться на всякий случай, чтобы ничего не поломалось, мало ли что за `<span>` может быть в шапке на какой-нибудь странице проекта.

Если записать стили для логотипа с помощью селектора класса с именем `logo`, станет более однозначно, к какому компоненту интерфейса эти стили относятся.: 

```
.logo {
	
}
```

Теперь,  если дизайнер решит убрать логотип, то стили для логотипа можно будет удалять без проблем. 

Селектор `header a` также не информативен: он может содержать CSS-правила для ссылки в меню шапки, ссылки с логотипа или, например, ссылки на профиль автора. Селектор класса `.logo`, напротив, сразу ограничивает круг ответственности. Даже если дизайнер решит перенести логотип из шапки в подвал, стили не сломаются.

///Изменение блока контекстом - для этого допускается объединять селекторы тега и класса
Изменение блока производится при помощи размещения одного блока в составе другого. Правила родительского блока применяются каскадом к вложенным блокам.

Самый распространенный случай использования контекста для стилизации блока — реализация блоков для комментариев в блогах или форумах любой CMS-системы.

Например, можно заранее определить правила для основных тегов, которые может применить пользователь:

```html
<div class="content">
	...
</div>
```

Внутри может происходить любой текст, картинки, разметка, которую захочет пользователь. Но все равно хочется придерживаться дизайна сайта и ограничить фантазию пользователя, чтоб не получить жирные курсиыные подчеркнутые заголовки в комментариях. Чтобы этого избежать, нужно заранее определить стили всех возможных элементов. Возможно, даже расставить им important!, чтобы ваши стили никто не мог перекрыть. 

```css
.content a {
	
}

.content p {
    font-family: Arial, sans-serif;
    text-align: center; 
}
```

## Почему не пользуемся общим сбросом стилей (reset)?

Общий сброс стилей это по сути глобальные CSS-правила, созданные для всей страницы. Это нарушает независимость компонентов и затрудняет их повторное использование.

На самом деле нет никакой причины сбрасыват стили и даже использовать normalize даже для отдельно вязтого компонента. Во время ”ресета“ или ”нормалайза“ появляются новые стили, которые потом в процессе работы приходится изменять и дорабатывать. Часто разработчик вынужден писать стили, кторые перекрывают то, что только что сбросили. 

## Почему не пользуемся универсальным селектором (*)?

Универсальный селектор сообщает о том, что какой-то стиль повлиял на все узлы в верстке. Если потом будет нужно использовать часть верстки повторно в другом проекте, окажется, что там этой звездочки нет и CSS-правил для нее, соответственно, тоже. 

Можно рассмотреть и противоположный случай, когда вы хотите использовать компонент из библиотеки в том же виде в проекте. Но если в проекте написан универсальный селектор, он может каким-то образом повлиять на этот компонент. Все сломается. 


```css
* {
	margin: 0;
	padding: 0;
}
```

Оно того не стоит. Общие стили не выигрывают время. Тк у большинства браузерных компонентов уже все стоит в ноль и сбрасывать марджины и паддинги. Даже для заголовков. Дизайнер принесет вам макет, в котором у заголовков скорее всего будут заданы марджины и паддинги.  Ивы сначала сбросите их, а потом будете писать стили и выставлять их как в макете. Бессмысленная раюота. 

### Почему не используем атрибуты

Рассмотрим пример с формой поиска в шапке. Если использовтаь атрибуты, то стили для этой формы могут выглядеть так:

```css
header input[type=submit],
header input[type=checkbox] {
	width: auto;
	margin-right: 20px;
}

header input[type=checkbox] {
	margin: 0;
}
```

В таком примере имена селеткоров снова неоднозначны. По ним нельзя утверждать, что стили относятся к форме поиска, и за что эта самая форма отвечает. Нагляднее записать классами. Тут никто не сдерживает нас писать понятно. Мы не ограничены набором тегов или атрибутов.

Можно записать, например, так:

```css
.form .search {
	
} 
```

Код стал более однозначным. Теперь понятно, что стили относятся к какой-то форме, которая отвечает за поиск. Но в таком случае возникает проблема вложенности селекторов. Вложенность повышает специфичность селекторов и мешает безболезненно переносить верстку из проекта в проект. Попрбуем от нее избавиться. Начнем с того, что разберем саму форму. 

## БЭМ — методология, проверенная временм

Мы подошли к тому, что нам хочется уметь переиспользовать какие-то части верстки и при этом видеть по именам в селекторах, какие части от каких зависят, чтобы при переносе не потерять составные части любого компонента. И при этом хочется быть уверенными, что ничего не сломалось и никто другой на новом проекте не перекроет ваши стили.

Попробуем применить БЭМ-методологию, чтобы все это провернуть.

Сверстав не одну сотню проектов, мы пришли к выводу, что нужно делить все, что есть на странице на блоки и элементы. В таком случае форма в интерфейсе окажется блоком `form`. Показывать в HTML, что этот блок — это форма, мы будем просто выстявляя ей класс с именем `form`: 

```
<form class="form" action="/">
```

Следующий шаг — научиться явно говорить, что блоки и элементы связаны между собой. 

Все составляющие формы, которые не могут существовать без нее, мы будем считать элементами блока `form`. Принадлежность элемента к блоку также выразим в классах: 

 ```html
<form class="" action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

Отделяем имя блока от имени элемента разделителем. Важно, чтобы разделители давали возможность на программном уровне отличать блоки от элементов и модификаторов. Классическая схема именования в БЭМ использует два подчеркивания.

Такие селекторы явно показывают связь между компонентами интерфейса. Теперь очевидно, что при переносе формы, необходимо скопировать все ее составляющие: 

```css
.form__search {
	
}

.form__submit {
	
}
```
 
Форма записи с помощью блоков и элементов в классах решает еще одну важную проблему - мы избавляемся от вложенности селекторов. У всех селекторов теперь всегда одинаковый вес. Это позволило решить проблемы с переопределением стилей.

С помощью имен блоков и элементов мы создали дополнительный уроовень семантики, который невозможно получить просто из разметки: 

```html
<form class="form" action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```
 
Теперь, когда вам понадобится такая же форма на странице или в другом проекте, достаточно будет просто скопировать ее. 

Но если вам нужна такая же форма поиска, которая выполняет абсолютно те же функции, но выглядеть по-другому (напрмер, формы в шапке и подвале). Первое, что может прийти в голову это написать форме дополнительные стили: 

```css
header .form {
	
}

footer .form {
	
}
```

Кажется, что это решает все проблемы, так как вес селектора `header .form` выше, чем у `form`, значит и правила будут перекрываться. Но при следующем переносе возникнут все те проблемы со вложенными селекторами, которые мы обсудили выше. 

Связвать код мы не хотим, вложенность не дает свободы в повторном использовании. Значит нужно избавится от вложенности. Для этого с помощью модификатора в классе опишем, что каждая из форм особенная, добавив стилей. 

```html
<form class="form form_type_original" action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

Такая запись говорит о том, что есть блок `form`, которому присвоен модификатор `type` со значением `original`. 
```
<form class="form form_type_original">
```

Для отделения имени модификатора используется одно подчеркивание. 

Форма может быть уникальна по разным показателям - цвету, размеру, типу, теме оформления. 
Модификаторов может быть разное количество: 

```
<form class="form form_type_original form_size_m form_theme_forest">
```

Модификаторы позволяют комбинировать разные свойства блока. Так одна и та же форма может выглядеть по-разному и при этом быть одного размера.  

Селекторы по-прежнему будут одного веса: 

```css
.form_type_original {
	
}

.form_size_m {
	
}

.form_theme_forest {
	
}
```

Важно! Модификаторы всегда размещаются на одном DOM-узле с блоком или элементом, к которому они относятся: 

```
<form class="form form_type_original form_size_m form_theme_forest">
```

Это позволяет один раз написать, как должна выглядеть универсальная форма:

```css
.form {
	
} 
```

и добавлять в стили модификатора только те свойства, которые отличают форму от ее базового вида. 

Так ничего не меняя, а просто создавая на одном DOM-узле нужную комбинацию, можно из каких-то общих компонентов получить очень частные случаи использования.

Модификаторы могут использоваться и для элементов:

<nav class="menu">
	<a class="menu__item" href=""></a>
	<a class="menu__item menu__item_current" href=""></a>
	<a class="menu__item" href=""></a>
</nav>

### Миксы

Бывает так, что различия блоков не только визуальные. Например, формы могут быть семантически разными: одна про поиск, другая про регистрацию, третья про заказ товаров интернет магазине. В таком случае выразить эти отличия модификаторами уже не получится. 
Но при этом все эти формы остаются формами. Как быть в этом случае? Общих стилей у них практически не останется. 

Можно было бы вынести общую часть таким образом: 

```css 
.form,
.search,
.register {
	
}
```

Но повторно использовать такой код вряд ли получится.
По-прежнему хочется, чтобы каждый компонент на странице был независим и выражался одним селектором. Для семантически разных блоков эту проблему решают миксы — подход, который придуман в БЭМ, но в аббревиатуру не поместился. С помоью миксов можно одновременно разместить несколько блоков на одном DOM-узле. 

Рассмотрим на примере, как работают миксы. Например, в проекте есть такая форма: 

```html
<form class="form " action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```
В селекторе класса `.form` описаны все стили, которые есть у любой формы, не важно форма заказов, поиска или регистрации. 

```css
.form {
	
}
```

Еще в проекте есть дополнительный класс `search`, который отвечает отдельно за форму поиска. Чтобы объединить стили класса `.form` и `.search`, нужно просто разместить эти классы на одном DOM-узле:

```html
<form class="form search" action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

В данном случае класс `search` — это отдельный блок, который отвечает за поиск. У этого блока не может быть никаких модификаторов, отвечающих за форму, темы, размеры. Зато этот класс определяет поведение формы. 

#### Миксы элемента

Элементы также можно миксовать к блокам, для 

Рассмотрим пример меню с пачкой ссылок: Все ссылки выражены блоком линк

```
<nav class="menu">
	<a class="link" href=""></a>
	<a class="link" href=""></a>
	<a class="link" href=""></a>
</nav>
```
 
Но нужно чтобы ссылка выглядела особенно только в меню. 

```
<nav class="menu">
	<a class="link" href=""></a>
	<a class="link menu__item" href=""></a>
	<a class="link" href=""></a>
</nav>
```

Миксуем с элементом


Про позиционирование пример 1:10

Позиционирование блока - миксы блока

Есть универсальное меню. Его нужно поставить на расстоянии 20пк от его родителей. Отступить вправо, чтоб он не прижимался к родительскому блоку. 
Очень распротр ситуация. Превое, что хочется сделать - написать эти стили блоку мнею

```css
.menu {
	margin-left% 20px;
}
```

а если есть менб в шапке и в подвале и отступы разные. Есть риск написать так: 

```
<div>
	<ul class="menu menu_type_header">
		<li class="menu__item"><a class="menu__link" href=""></a></li>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
	</ul>
</div>
```

```css
.menu_type_header {
	margin-left% 20px;	
}

.menu_type_footer {
	margin-left% 30px;	
}
```
как буд-то у нас ест ьдва типа меню. Но это тот же случай, что с формой про поиск и общей. Это  не какое-то свойство меню быть с отсупом в 20 пк от левого края. А это скорее свойство родительского блока (шапки) - его вложенный блок должен отступать от грацы в 20px . 

Знания про отсупы должны содержаться в блоке шапки в его эелементе. То есть у нас есть шапка и мы знаем, что внутри шапки ест ьразные неотрываемы от шапки штуки - лого, меню, форма поиска. И эти неотрываемые части должны отсупать от края 20 пк. И важно, что если меню заменить на другой блок, потому что его перенесли в сайдбар, например на форму поиска. Новый блок будет также отсупать от края 20 пк и ничего не поломается. И в то же время меню в сайдбаре не будет содержать лишнюю инфу об отсупах для шапки. у него не будет никаких стилей рпо позиуионирование. Оно будет универсальным и будет одинаково работать, независимо от того, куда бы мы его не положили. 

```
<div>
	<ul class="menu header__menu">
		<li class="menu__item"><a class="menu__link" href=""></a></li>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
	</ul>
</div>
```




Про вложенность элементов: 

```
<div>
	<ul>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
		<li class="menu__item"><a class="menu__link" href=""></a></li>
	</ul>
</div>
```

рассказать про пересечение стилей. что решаем неймингом (52 минута)

рассказть про врапперы. что нет необходимости создавать врапперы для блоков. Это может решаться за счет элементов родительского блока. 

если внутренни враппер может переезжать с проекта на проект вместе с блоком. 


5. Модификаторы нужны для модификации блоков или элементов

6. Элементы - Это части блоков, которые не имеют смысла вне своего родителя. Позволяют экономить на пересечении имен классов, легче читать селекторы и гарантируют непересекаемость стилей (вес селектора сохраняется).

7. 


Удобство параллельной разработки. 

В макете любого сайта много повторяющихся деталей. Шапка и подвал понятно, но помимо этого все ссылки выглядят одинаково, все кнопки одинаковые, панель навигации, есть стоит кирпичи например привюшка чего-то 










пока никуда не попало: 


3. 
// Изменение блока контекстом - для этого допускается объединять селекторы тега и класса
Изменение блока производится при помощи размещения одного блока в составе другого. Правила родительского блока применяются каскадом к вложенным блокам.

Важно Изменять внешний вид и поведение блока контекстом следует только в том случае, если невозможно использовать микс. Изменения с помощью контекста ограничивают независимость блоков.

Самый распространенный случай использования контекста для стилизации блока — реализация блоков для комментариев в блогах или форумах любой CMS-системы.

Например, можно заранее определить правила для основных тегов, которые может применить пользователь:

<div class="content">
	...
</div>

И тут внутри может происходить любой текст, картинки, разметка, которую захочет пользователь. Но У нас же есть дизайн сайта и мы не хотим получить жирные курсиыные подчеркнутые заголовки комментариев. Для этого нам необходимо заранее определить стили всех возможных элементов. Возможно даже расставить им important!, чтоб эти стили никто не мог перекрыть. 

```css
.content a {
	
}

.content p {
    font-family: Arial, sans-serif;
    text-align: center; 
}
```
///
















В конце в выводах: 

если знать, как выглядит хорошее, плохого не захочется. 