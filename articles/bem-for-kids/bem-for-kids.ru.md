# БЭМ для начинающих и не только

Эта статья написана по мотивам БЭМапа с одноименным названием [БЭМ для начинающих](https://www.youtube.com/watch?v=Ai-yt0b8iKE). 

Нас часто спрашивают о верстке по БЭМ и про технологии, которые мы используем: почему нужно делать так, а не иначе? Зачем мы создали целый [стек новых технологий](https://ru.bem.info/platform/), когда можно пользоваться готовыми? Зачем придумали длинные и некрасивые имена в классах? 

На БЭМапе [Владимир Гриненко](https://github.com/tadatuta) дал ответы на эти вопросы. Мы решили их увековечить в статье.

**Основные почему:**
* [Почему не используем ID?](#)
* [Почему не используем селекторы тега?](#)
* [Почему не используем селеторы атрибутов?](#)
* [Почему не используем универальный селектор?](#)
* [Почему не используем общий сброс стилей?](#)
* [Почему не используем вложенные селекторы?](#)
* [Почему не совмещаем тег и класс в селеткоре?](#)
* [Почему не используем комбинированные селеторы?](#)

**Немного теории и практики:**
* [Основы БЭМ](#)
* [Микс блоков и элементов](#)
* [Удобство параллельной разработки и верстка блоками](#)
* [БЭМ для JavaScript](#)
* [Шаблоны в БЭМ](#)
* [Тестирование верстки](#)

## Зачем вам БЭМ

БЭМ предоставляет единые правила написания и хранения кода, которые помогают масштабировать и повторно использовать код, увеличить производительность и упростить командную работу. Даже если вся ваша команда — это вы сами, БЭМ может быть вам полезен. 

Чтобы понять, как «работает» БЭМ, мы рассмотрим простой пример web-страницы:

* [HTML-разметка](https://gist.github.com/innabelaya/be3ac2f2bc9b3466afba12bfb6dd1d8c)
* [CSS](https://gist.github.com/innabelaya/895cb5bd6efe4768588a9895f80bbc07)
* [Сохраненный проект в JSFiddle]()

## Основные Почему?

### Не используем идентификаторы (ID селекторы)

Весь смысл ID в том, что он определяет уникальное имя HTML-элемента. Если имя уникально, то второй раз в интерфейсе его использовать не получится. Это мешает реализовать принципы БЭМ о повторном использовании кода.

#### Возможные исключения

Первое распространенное мнение и заблуждение: ID обязателен для работы с JavaScript. На практике современным браузерам не важно, с какими данными работать: с ID или классами. Браузер одинаково быстро обработает любой селектор.

Второй распространенный случай применения ID — это тег `<label>`. Но, если завернуть `<label>` в контрол, ID становится не нужен.

```html
<input id="идентификатор"><label for="идентификатор">Текст</label>
<label><input type="..."> Текст</label>
```

Третий допустимый случай применения ID — установка якоря на странице. Тут аргументы закончились, если нужно, ставьте.

### Не используем селекторы тега

HTML-разметка страниц нестабильна: новый дизайн сайта может поменять вложенность разделов и изменить уровень заголовоков с `<h1>` на `<h3>`, или превратить абзац `<p>` в тег `<div>`. Любые подобные изменения сломают существующие стили в проекте. 

Набор тегов ограничен, поэтому при использовании верстки из одного проекта в другом вероятность столкнуться с конфликтами стилей, написанных на одни и те же теги, возрастает в разы. Стили будут перекрываться, накладываться и ломаться.

Даже расширенный набор семантических тегов не может выразить все потребности верстки. Рассмотрим распространенный пример макета: на странице расположена шапка с логотипом, по клику на который открывается главная страница сайта. 

Попробуем написать разметку с помощью тегов. Для вставки каринки существует тег `<img>`, а для  перехода на главную страницу — тег `<a>`. 

```html
<header>
	<a href="/">
		<img src="img.logo.png" alt="Лого">
	</a>
</header>
```

Но в проекте все картинки будут выражены тегом `<img>` и все ссылки — тегом `<a>`. А нам нужно уметь отличать логотип от картинки и ссылку с логотипа от ссылки в навигационном меню и от обычной ссылки в контенте страницы. Для ссылок в шапке понадобятся отдельные стили, которые отменят подчеркивание и синий цвет:

```css
header a {
	...
}
```

Еще ссылка с логотипа на всех страницах ведет на главную страницу сайта, а на самОй главной странице такая ссылка уже не нужна. Поэтому на главной странице разметка скорее всего будет следующей: 

```html
// Код для index страницы
<header>
	// тег <a> заменен на <span> 
	<span>  
		<img src="img.logo.png" alt="Лого">
	</span>
</header>
```

На главной странице ссылка в логотипе выражена тегом `<span>`, для которого отменять подчеркивание и синий цвет нет необходимости. Поэтому часть правил запишем так:

```css
header a,
header span,
{
    ...
}
```

Такой код не вносит ясности в проект. Если вновом дизайне нужно удалить логотип, разработчик скорее всего оставит эти стили в проекте «на всякий случай», потому что непонятно, что за `<span>` может быть в шапке на какой-нибудь странице проекта.

Чтобы избежать всех этих проблем и путаницы, достаточно записать стили для логотипа с помощью селектора класса с именем `logo`: 

```
.logo {
	
}
```

Теперь, если дизайнер решит убрать логотип, разработчику будет знать, какие стили удалять.

Селектор `header a` также не информативен: он может содержать CSS-правила для ссылки в меню шапки, ссылки с логотипа или, например, ссылки на профиль автора. 

#### Возможные исключения

Методология в редких случаях допускает объединение селекторов тега и класса, например, для реализации блоков с комментариями в блогах или форумах любой CMS-системы. Пользователь может написать любой текст, вставить картинки, добавить любую разметку. Но чтобы оставаться в рамках дизайна сайта, можно заранее определить стили всех возможных элементов.

Например, написать правила для основных тегов, которые доступны пользователю, и применять их каскадом к вложенным блокам:

```html
<div class="content">
	...
</div>
``` 

```css
.content a {
	
}

.content p {
    font-family: Arial, sans-serif;
    text-align: center; 
}
```

### Не используем общий сброс стилей (reset)?

Общий сброс стилей это по сути те же глобальные CSS-правила, созданные для всей страницы. Всё глобальное, оказывающее влияние на все узлы верстки, нарушает независимость компонентов и затрудняет их повторное использование.

В БЭМ не используется `reset` и `normalize` даже для отдельно вязтого блока. 
Во время «ресета» или «нормалайза» существующие стили отменяются и подменяются другими, которые потом в процессе работы приходится всё равно изменять и дорабатывать. В итоге разработчик вынужден писать стили, кторые перекрывают то, что только что сбросили с помощью reset или `normalize`. Очень похоже на тот самый monkey business, который так не любят все разработчики.

### Не используем универсальный селектор (*)?

Универсальный селектор сообщает о том, что какой-то стиль повлиял на все узлы в верстке. Использовать повторно такую верстку в другом проекте становится труднее:
* Необходимо дополнительно переносить в проект и стили под «звездочкой». Но тогда универсальный селектор может неожиданно повлиять на существующие стили в новом проекте.
* Необходимо менять все стили в переносимой верстке, добавляя всё, что давала «звездочка».

Универсальный селектор не только затрудняет повторное использование верстки в разных проетках, но и может сделать ваш код непредсказуемым. Например, универсальный селектор в вашем может повлиять на стили компонента из универсально библиотеки. 

Общие стили не выигрывают время. Рассмотрим на примере: дизайнер приносит макет, в котором у заголовков заданы отступы (`margin: 12px; padding: 30px;`). Разработчик сначала сбрасывает все стили `* { margin: 0; padding: 0; }` для универсальных компонентов, а потом снова выставляет отступы, как в макете.

### Не используем вложенные селекторы

Вложенные селекторы увеличивают связность кода и делают его повторное использование невозможным.
Методология БЭМ допускает использование вложенных селекторов, но рекомендует свести их к минимуму. 

Вложенность уместна, если нужно изменить стили элементов в зависимости от состояния блока или заданной темы:

```css
.button_hovered .button__text
{
    text-decoration: underline;
}

.button_theme_islands .button__text
{
    line-height: 1.5;
}
```

### Не используем комбинированные селекторы

Комбинированные селекторы (например, `.button.button_theme_islands`) имеют более высокую специфичность, чем одиночные селекторы. Переопределять блоки становится сложнее.

```html
<button class="button button_theme_islands">...</button>
```

CSS-правила заданы в селекторе `.button.button_theme_islands`.

Допустим, блоку добавили модификатор `active` в значении `true`:

```html
<button class="button button_theme_islands button_active">...</button>
```

Селектор `.button_active` не переопределит свойства блока, записанные как `.button.button_theme_islands`, так как специфичность `.button.button_theme_islands` выше, чем у `.button_active`. Для успешного переопределения селектор модификатора блока также должен быть скомбинирован с селектором `.button` и объявлен ниже `.button.button_theme_islands`, так как специфичность обоих селекторов одинакова:

```css
.button.button_theme_islands {}
.button.button_active {}
```

Если использовать простые селекторы классов, переопределение стилей не вызовет проблем:

```css
.button_active {}
.button {}
```

### Не совмещаем тег и класс в селекторе

Объединение тега и класса (например, `button.button`) повышает специфичность CSS-правил, что усложняет задачу их переопределения. Это приводит к войнам значимости, при которых таблицы стилей загружаются излишне сложными селекторами.

```html
<button class="button">...</button>
```

CSS-правила заданы в селекторе `button.button`.

Допустим, блоку добавили модификатор `active` с значением `true`:

```html
<button class="button button_active">...</button>
```

Селектор `.button_active` не переопределит свойства блока, записанные как `button.button`, так как специфичность `button.button` выше чем у `.button_active`. Для успешного переопределения селектор модификатора блока также должен быть скомбинирован с тегом `button.button_active`.

В результате развития проекта могут, например, появиться блоки с селекторами `input.button`, `span.button` и `a.button`. В таком случае все модификаторы блока `button` и вложенные в него элементы потребуют четыре разные декларации для каждого случая.

### Не используем селекторы атрибутов

Селекторы атрибутов по информативности уступают селекторам классов. Чтобы доказать это, рассмотрим пример с формой поиска в шапке: 

```html
<header>
	<form action="/">
		<input name="s">
		<input type="submit">
	</form>
</header>
```

Воспользуемся селекторами атрибутов, чтобы записать стили для формы:

```css
header input[type=submit],
header input[type=checkbox] {
	width: auto;
	margin-right: 20px;
}

header input[type=checkbox] {
	margin: 0;
}
```

В таком примере невозможно однозначно определить по именам селекторов, что стили относятся к форме поиска. Нагляднее записать классами. В классах нет ограничений, чтобы писать понятно.

Можно записать, например, так:

```css
.form .search {
	...
} 
```

Код стал более однозначным: теперь понятно, что стили относятся к форме, которая отвечает за поиск. 

Но вложенность селекторов по-прежнему повышает специфичность CSS-правил и мешает безболезненно переносить верстку из проекта в проект. Чтобы избавиться от вложенности, воспользуемся принципами БЭМ. 

> **Короткие выводы**
>
> * Классы — единственный селектор, который позволяет организовать стили проекта и не ограничивать при этом повторное использование верстки.

> * Классы — единственный селектор, который позволяет изолировать стили каждого компоеннта в проекте и повторно использовать верстку.
> * Вложенные селекторы, общий сброс стилей и универсальный селектор делают повторное использование кода невозможным. 
> * Вложенность повышает вес селектора и затрудняет переопределение стилей.

## БЭМ. От теории к практике

* Основы БЭМ
* Микс блоков и элементов
* Удобство параллельной разработки и верстка блоками
* Блоки в файловой структуре 
* БЭМ для JavaScript
* Шаблоны в БЭМ
* Тестирование верстки

### Основы БЭМ


Методология БЭМ — это набор универсальных принципов, которые можно применять независимо от используемых технологий, будь то CSS, Sass, HTML, JavaScript или React.

БЭМ помогает решить следующие задачи:
* повторно использовать верстку
* безболезненно менять куски верстки местами в одном проекте
* переносить готовую верстку из проекта в проект 
* создавать стабильный и предсказуемый код
* писать понятный код 

В БЭМ-проекте любой интерфейс делится на [блоки](), которые могут содержать [элементы](). Элементы не существуют вне блока. Каждый элемент может принадлежать только одному блоку. Именно блокам и элементам посвящены первые две буквы в аббревиатуре БЭМ.

Имя блока всегда уникально. Оно задает пространство имен для элементов и модификаторов блока. И устанавливает видимую связь между всеми составляющими блока. Длинные но понятные имена блоков и элементов позволяют увидеть, как компненты интрефейса зависят друг от друга (помогают определить связь между компонентами) и не потерять составные части любого компонента при переносе верстки. 

Суть [именования]() компонентов в БЭМ в том, что в имени можно явно указать связь блока и его элементов.

Имя блока задает пространство имен его элементов и явно показывает связь между компонентами интерфейса. 

Чтобы показать всю силу БЭМ-нейминга, рассмотрим тот же пример с формой. По БЭМ-методологии форма будет выражена блоком `form`. В HTML имя блока всегда записывается в атрибуте `class`: 

```html
<form class="form" action="/">
```

Все части формы (блок `form`), которые не имеют смысла в отрыве от нее, считаются элементами блока `form`. Таким образом поле ввода (`search`) и кнопка (`submit`) — это элементы блока `form`. Принадлежность элемента к блоку также выражается в имени через классы: 

 ```html
<form class="" action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

Обратите внимание, что имя блока отделяется от имени элемента специальным разделителем. В [классической схеме именования]() в БЭМ для разделителя используются два подчеркивания. Разделители могут быть любыми. Существуют [альтиернативные схемы](), и каждый разработчик выбирает наиболее удобную для себя. Важно, чтобы разделители давали возможность на программном уровне отличать блоки от элементов и модификаторов. 

Вернемся к примеру. Из имен селекторов очевидно, что для переноса формы в другой проект, необходимо скопировать все ее составляющие: 

```css
.form__search {
	
}

.form__submit {
	
}
```
 
Запись имен в классах с помощью блоков и элементов решает еще одну важную проблему: избавляет от вложенности селекторов. У всех селекторов в БЭМ-проекте одинаковый вес. То есть переопределять стили теперь гораздо удобнее. 

Теперь, когда вам понадобится такая же форма на странице или в другом проекте, достаточно будет просто скопировать ее разметку и стили. 
 
### Третья буква в аббревиатуре БЭМ

Официально буква «М» означает «модификатор», но негласно под нее попадает еще одно очень важное понятие в БЭМ – «микс». И модификаторы и миксы измененяют блок и его элементы. Давайте рассмотрим подробнее.

#### Модификаторы

Модификатор определяет внешний вид, состояние или поведение блока либо элемента.

Наличие модификаторов опционально. Модификаторы позволяют комбинировать разные свойства блока, так как можно использовать неограниченное количество модификаторов. Но блоку или элементу нельзя одновременно присвоить разные значения одного и того же модификатора.

Предположим, в проекте нужна такая же форма поиска, которую мы рассмотрели выше. Она будет выполнять те же функции, но выглядеть по-другому (напрмер, разный вид у форм поиска в шапке и в подвале страницы). Первое, что может прийти в голову — это написать форме дополнительные стили: 

```css
header .form {
	
}

footer .form {
	
}
```

Так можно решить эту задачу: вес селектора `header .form` выше, чем у `form`, значит правила будут перекрываться. Но мы уже [обсудили](), что вложенность селекторов связывает код и мешает его переиспользовать. Значит такое решение не подходит. В БЭМ можно добавить блоку новые стили с помощью модификатора: 

```html
<form class="form form_type_original" action="/">   // Добавили модификатор form_type_original
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

Запись `<form class="form form_type_original"></form>` говорит о том, что блоку `form` присвоен модификатор `type` со значением `original`. Имя модификатора отделяется от имени блока или элемента одним подчеркиванием.
 
Форма может быть уникальна по разным показателям - цвету, размеру, типу, теме оформления. Так одна и та же форма может выглядеть по-разному и при этом быть одного размера:

```
<form class="form form_type_original form_size_m form_theme_forest"></form>
<form class="form form_type_original form_size_m form_theme_sun"></form>
```

Селекторы для каждого модификатора все равно будут иметь один вес: 

```css
.form_type_original {
	
}

.form_size_m {
	
}

.form_theme_forest {
	
}
```

Модификатор содержит только дополнительные стили, которые как-то изменяют исходную реализацию блока. Это позволяет один раз написать, как должна выглядеть универсальный блок и добавить в стили модификатора только те свойства, которые отличают блок от его исходного вида. 

```css
.form {
	стили для универсального блока
} 

. form_type_original {
	дополнительные стили
}
```

Поэтому модификатор всегда должен находиться на одном DOM-узле с блоком или элементом, к которому он относится.

```
<form class="form form_type_original"></form>
```

Неверная форма записи:

```
<form class="form_type_original"></form>   // Удалили имя блока из класса 
```

Модификатор позволяет получать очень частные случаи использования общих компонентов. При этом код блока или элемента не меняется, на DOM-узле просто создается нужная комбинация из модификтаоров.

#### Миксы

Микс позволяет одинаково форматировать разные HTML-элементы, совмещать поведение и стили нескольких сущностей без дублирования кода и решать задачи абстрактных блоков-оберток, отвечающих за внешнее позиционировнаие блока.

Миксом называется одновременное размещение нескольких БЭМ-сущностей (блоков, элементов, модификаторов) на одном DOM-узле. 

Различия блоков могут быть не только визуальными: блоки могут быть семантически разными. Например, форма поиска, форма регистрации и форма заказа товаров — это все формы, и в верстке они будут выражены блоком `form`, хотя общих стилей у них практически не будет. Отобразить такие отличия с помощью модификаторов невозможно.

Если вынести общие стили для таких блоков, то повторно использовать такой код не получится. 

```css 
.form,
.search,
.register {
	
}
```

Рассмотрим, как можно создать семантически разные блоки с помощью микса на примере той же формы: 

```html
<form class="form " action="/">
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

В селекторе класса `.form` описаны все стили, которые есть у любой формы (заказов, поиска или регистрации):

```css
.form {
	
}
```

Теперь предстоит сделать из универсальной формы форму поиска. Для этого в проекте необходимо создать дополнительный класс `search`, который отвечает только за поиск. Чтобы объединить стили класса `.form` и `.search`, нужно разместить эти классы на одном DOM-узле:

```html
<form class="form search" action="/">          // Микс блоков form и search
	<input class="form__search" name="s">
	<input class="form__submit" type="submit">
</form>
```

В данном случае класс `.search` — это отдельный блок, который определяет поведение формы и отвечает за поиск. У этого блока не может быть модификаторов, отвечающих за форму, темы, размеры. Такие модификаторы уже есть у универсальной формы.

Рассмотрим еще один пример, когда меняется семантика компонента. Для примера возьмем навигационное меню в шапке страницы, в котором все пункты меню должны быть ссылками:

```
<nav class="menu">
	<a class="link" href=""></a>
	<a class="link" href=""></a>
	<a class="link" href=""></a>
</nav>
```

Нужная функциональность для ссылок уже реализована в проекте в блоке `link`. Но ссылки в меню должны отичаться визуально от ссылок в тексте. Существует несколько способов изменить ссылки в меню:

1. Создать модификатор для пункта меню, который превратит пункт в ссылку: 

```
<nav class="menu">
	<a class="menu__item menu__item_link" href=""></a>
	<a class="menu__item menu__item_link" href=""></a>
	<a class="menu__item menu__item_link" href=""></a>
</nav>
```

Но в таком случае для реализации модификатора придется скопировать поведение и стили блока `link`. Это приведет к дублированию кода.

2. Воспользоваться миксом универсального блока `link` и элемента `item` блока `menu`:

```
<nav class="menu">
	<a class="link menu__item" href=""></a>
	<a class="link menu__item" href=""></a>
	<a class="link menu__item" href=""></a>
</nav>
```

Микс двух БЭМ-сущностей позволит применить базовую функциональность ссылок из блока `link` и дополнительные CSS-правила из блока `menu`, и не копировать код.

##### Внешняя геометрия и позиционирование

Миксы применяют, чтобы расположить один блок относительно другого или позиционировать элементы внутри блока.

В БЭМ стили, отвечающие за внешнюю геометрию и позиционирование, задаются через родительский блок.

Рассмотрим на примере универсального блока меню, который нужно разместить в шапке. В верстке блок меню должен отступать от родителького блока на 20px. Превое, что хочется сделать — написать стили с отступами самому блоку мнею:

```css
.menu {
	margin-left% 20px;
}
```

Как только вы это сделаете, ваш блок меню перестанет быть универсальным. Если понадобится разместить такой же блок меню в подвале но с другими отступами, вам придется править стили. 

Второе, что можно сделать — создать модификатор для блока меню: 

```
<div>
	<ul class="menu menu_type_header">
		<li class="menu__item"><a href=""></a></li>
		<li class="menu__item"><a href=""></a></li>
		<li class="menu__item"><a href=""></a></li>
	</ul>
</div>
```

```css
.menu_type_header {
	margin-left% 20px;	
}

.menu_type_footer {
	margin-left% 30px;	
}
```

Но в таком случае у нас появляется два типа меню, а это не так. Меню остается одно и то же.

Третий вариант определить внешнее позиционирование блока — вложить блок `menu` в абстрактную обертку (например, блок `wrapp`), где определить все отступы:

```
<div class="wrap">
	<ul class="menu">
		<li class="menu__item"><a href=""></a></li>
		<li class="menu__item"><a href=""></a></li>
		<li class="menu__item"><a href=""></a></li>
	</ul>
</div>
```

Чтобы окончательно отказаться от соблазна создавать модификаторы и менять стили самого блока для позиционирования его на странице, нужно осознать, что отступ от родительского блока — это не свойство вложенного блока быть с таким отступом. Это свойство родительского блока - знать, что вложенный в него блок должен отступать от границы на определенное количество пикселей. 

Знания про позиционирование вложенных блоков описываются в элементах родительского блока. Затем элемент родительского блока миксуется к вложенному блоку. В таком случае вложенный блок не специфицирует никакие отступы и может быть легко переиспользован в любом месте.

Продолжим рассматривать наш пример:

```
<div>
	<ul class="menu header__menu">
		<li class="menu__item"><a href=""></a></li>
		<li class="menu__item"><a href=""></a></li>
		<li class="menu__item"><a href=""></a></li>
	</ul>
</div>
```

Здесь внешняя геометрия и позиционирование блока `menu` задана через элемент `header__menu`. Блок `menu` не специфицирует никакие отступы и может быть легко переиспользован в любом месте.

Элемент родительского блока (в нашем случае это `header__menu`) полностью решает задачу абстрактных блоков-оберток, отвечающих за внешнее позиционировнаие блока.

### Удобство параллельной разработки

В БЭМ любой макет делится на мельчайшие блоки (ссылка, кнопка, меню и так далее). Благодаря тому, что блоки не зависят друг от друга напрямую, они могут разрабатываться параллельно разными разработчиками. Разработчик создает блок как универсальный компонент, который может быть переиспользован в любом другом проекте.

В качестве примера рассмотрим библиотеку блоков [bem-components](), которая содержит универсальные блоки, такие как ссылка, кнопка, поле ввода. Из универсальных компонентов легко создавать блоее сложные блоки. Например, селект или чекбокс.

По-блочная верстка проекта помогает сократить время на интеграцию кода разных разработчиков, гарантирует уникальность имен каждого компонента и позволяет тестировтаь блоки на стадии разработки. 

### Блоки в файловой структуре 

Все БЭМ-проекты имеют схожую [файловую структуру](https://ru.bem.info/methodology/filestructure/). Привычное для разработчиков расположение файлов облегчает навигацию по проекту, упрощает переключение между проектами и перенос блоков из одного проекта в другой. 

Реализация каждого блока хранится в отдельной папке проекта. Каждой технологии (CSS, JavaScript,тесты, шаблоны, документация, картинки) соответствует отдельный файл. 

Например, если внешний вид блока `input` задан с помощью CSS, то код будет сохранен в файле `input.css`.

```
project
    common.blocks/
        input.css       # Реализация блока input в технологии CSS
        input.js        # Реализация блока input в технологии JavaScript
```

Код модификаторов и элементов также хранится в отдельных файлах блока. Такой подход позволяет подключать только те модификаторы и элементы, которые необходимы для данной реализации блока.

```
project
    common.blocks/
        input.css             # Реализация блока input в технологии CSS
        input.js              # Реализация блока input в технологии JavaScript
        input_theme_sun.css   # Реализация модификатора input_theme_sun
        input__clear.css      # Реализация элемента input__clear в технологии CSS
        input__clear.js       # Реализация элемента input__clear в технологии JavaScript
```

Чтобы улучшить навигацию в проекте, модификаторы блока со множественными значениями также можно объединять в отдельные директории. 

Файловая структура любого БЭМ-проекта состоит из [уровней переопределния](https://ru.bem.info/methodology/key-concepts/#Уровень-переопределения). Уровни переопределения позволяют:
* Разделять проект на платформы
* Легко обновлять библиотеки блоков, подключенные в проект
* Использовать общие блоки для разработки разных проектов
* Менять темы оформления, не затрагивая логику работы проекта
* Проводить эксперименты в рабочем проекте

> Подробнее про [уровни переопределения](https://ru.bem.info/methodology/redefinition-levels/).

Поблочная разработка и хранение всех технологий блока в одной папке облегчает перенос блока из проекта в проект. Чтобы вместе с версткой перенести все стили и поведение блока, достаточно скопировать папку этого блока в новый проект. 

### Шаблонизация в БЭМ

В HTML разметка блока повторяется каждый раз, когда блок встречается на странице. Если разработчик пишет HTML вручную, исправлять ошибку или вносить дополнительные изменения необходимо в каждом экземпляре блока в разметке. Чтобы генерировать HTML-код и применять правки автоматически, в БЭМ используются шаблоны: блоки сами отвечают за то, как они будут представлены в HTML. 

BEMTREE преобразует данные в BEMJSON. Шаблоны описываются в BEMJSON-формате в файлах с расширением `.bemtree.js`.

BEMHTML преобразует BEMJSON-описание страницы в HTML. Шаблоны описываются в файлах с расширением `.bemhtml.js`.

Если шаблоны к блокам не написаны, шаблонизатор по умолчанию установит блокам тег `<div>`. 

Сравните декларацию блоков и выходной результат HTML:

Декларация: 

```
{
	block: 'menu',
	content: [
		{
			elem: 'item',
			content: {
			    block: 'link'
		    }
	    },
	    {
			elem: 'item',
			elemMods: { current: true },  // Задали модификтаор пункту меню
			content: {
			    block: 'link'
		    }
	    }
	]
}
```

HTML:

```html
<div class="menu">
	<div class="menu__item">
         <div class="link"></div>
	</div>
    <div class="menu__item menu__item_current">
         <div class="link"></div>
	</div>
</div>
```

Чтобы изменить разметку блока `menu`, необходимо написать шаблоны для блока:


1. Меняем тег блока `menu`:

  ```
  block('menu')(
      tag()('menu')  // устанавливает тег menu для блока меню
  )
  ```
  
  Измененный HTML:
  ```html
  <menu class="menu"> // Замена тега div на menu для блока menu
  	  <div class="menu__item">
           <div class="link"></div>
  	  </div>
      <div class="menu__item menu__item_current">
           <div class="link"></div>
	  </div>
  </menu>
  ```
  По аналогии с CSS, шаблон будет применен ко всем блокам `menu` на странице. 
   
2. Добавляем дополнительный элемент (`menu__inner`), который выполнит функцию внутренней обертки и будет отвечать за расположение элементов внутри блока `menu`. Изначально элемент `menu__inner` не указывался в декларации, поэтому необходимо добавить его на этапе сборки шаблонов.  
  Шаблоны в БЭМ написаны на JavaScript, поэтому добавить новый элемент в шаблон также можно с помощью JavaScript:

  ```
  block('menu')(
      tag()('menu'),
      content()(function() {
          return {
              elem: 'inner',
              content: this.ctx.content
      }
  })
  )
  ```
  HTML:

  ```html
  <menu class="menu"> // Замена тега div на menu для блока menu
	  <div class="menu__inner">
	  	  <div class="menu__item">
	           <div class="link"></div>
	  	  </div>
	      <div class="menu__item menu__item_current">
	           <div class="link"></div>
		  </div>
	  </div>
  </menu>
  ```

3. Изменяем теги всем элементам `inner` и `item`:  
  ```
  block('menu')(
      tag()('menu'),
      content()(function() {
          return {
              elem: 'inner',
              content: this.ctx.content
          }
      }),
      elem('inner')(
          tag()('ul')
      ),
      elem('item')(
          tag()('li')
      )
  )
  ```
  HTML:

  ```html
  <menu class="menu"> // Замена тега div на menu для блока menu
	  <ul class="menu__inner">
	  	  <li class="menu__item">
	           <div class="link"></div>
	  	  </li>
	      <li class="menu__item menu__item_current">
	           <div class="link"></div>
		  </li>
	  </ul>
  </menu>
  ```
4. Выставляем тег `<a>` всем ссылкам на странице:
  ```
  block('menu')(
      tag()('menu'),
      content()(function() {
          return {
              elem: 'inner',
              content: this.ctx.content
          }
      }),
      elem('inner')(
          tag()('ul')
      ),
      elem('item')(
          tag()('li')
      )
  );
  
  block('link')(
      tag()('a')
  );
  ```
  HTML:

  ```html
  <menu class="menu"> 
	  <ul class="menu__inner">
	  	  <li class="menu__item">
	           <a class="link"></a>
	  	  </li>
	      <li class="menu__item menu__item_current">
	           <a class="link"></a>
		  </li>
	  </ul>
  </menu>
  ```
5. Изменяем существующий шаблон. Правила в шаблонах применяются так же, как в CSS: нижнее правило перекрывает верхнее. Добавим новые правила в шаблон, изменим тег ссылкам с `<a>` на `<span>`:
  ```
  block('link')(
      tag()('a')
  );
  
  block('link')(
      tag()('span')
  );
  ```
  HTML:

  ```html
  <menu class="menu"> 
	  <ul class="menu__inner">
	  	  <li class="menu__item">
	           <span class="link"></span>
	  	  </li>
	      <li class="menu__item menu__item_current">
	           <span class="link"></span>
		  </li>
	  </ul>
  </menu>
  ```

### Тстирование верстки

Протестировать работу всей страницы проблематично. Особенно в динамическом проекте, который связан с базой данных. А отдельные блоки покрывать тестами (unit) достаточно просто. Когда вы можете гарантировать, что все отдельные блоки у вас работают правильно, то все, что остается, убедится, что вся обвязка для блоков работает правильно. 

### Сборка проекта

Для удобства работы с кодом в БЭМ-проекте все блоки и технологии разложены по отдельным папкам и файлам. Чтобы объединить исходные файлы в один (например, все CSS-файлы в project.css, все JS-файлы в project.js и т. п.), используется сборка. 

Сборка решает следующие задачи:

* Объединяет исходные файлы, разложенные по файловой структуре проекта.
* Подключает в проект только необходимые блоки, элементы и модификаторы (БЭМ-сущности).
* Учитывает порядок подключения.
* Обрабатывает код исходных файлов в процессе сборки (например, компилирует LESS-код в CSS-код).

Чтобы включить в сборку только необходимые БЭМ-сущности, необходимо составить список блоков, элементов и модификаторов, используемых на странице. Такой список называется декларацией.

Так как в БЭМ блоки могут строиться на основании других блоков, необходимо также указывать зависимости от них. За это отвечает отдельная технология в БЭМ — файлы `deps.js`. По файлам зависимостей инструмент сборки понимает, какие блоки дополнительно подключить в проект. 
